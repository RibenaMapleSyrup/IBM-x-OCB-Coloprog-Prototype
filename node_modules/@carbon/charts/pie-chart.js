var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// D3 Imports
import { select } from "d3-selection";
import { scaleOrdinal } from "d3-scale";
import { pie, arc } from "d3-shape";
import { interpolate } from "d3-interpolate";
import { BaseChart } from "./base-chart";
import * as Configuration from "./configuration";
import { ChartType } from "./configuration";
import { Tools } from "./tools";
var PieChart = /** @class */ (function (_super) {
    __extends(PieChart, _super);
    function PieChart(holder, configs, type) {
        if (type === void 0) { type = ChartType.PIE; }
        var _this = _super.call(this, holder, configs) || this;
        _this.getTooltipHTML = function (d) { return _this.generateTooltipHTML(d.data.label, d.value.toLocaleString()); };
        _this.options.type = type;
        // Assign colors to each slice using their label
        _this.colorScale = scaleOrdinal(_this.options.colors);
        return _this;
    }
    // Sort data by value (descending)
    PieChart.prototype.dataProcessor = function (dataObject) {
        // TODO - Support multiple datasets
        if (dataObject.datasets.length > 1) {
            console.warn("Currently the Pie & Donut charts support a single dataset,\n\t\t\t\tyou appear to have more than that. Will only use your first provided dataset.");
        }
        // Check for duplicate keys in the data
        var duplicates = Tools.getDuplicateValues(dataObject.labels);
        if (duplicates.length > 0) {
            console.error(Tools.capitalizeFirstLetter(this.options.type) + " Chart - You have duplicate keys", duplicates);
        }
        // TODO - Support multiple datasets
        var dataList = dataObject.datasets[0].data.map(function (datum, i) { return ({
            label: dataObject.labels[i],
            value: datum,
        }); });
        // Sort data by value
        var sortedData = dataList.sort(function (a, b) { return b.value - a.value; });
        return {
            // Sort labels based on the order made above
            labels: sortedData.map(function (datum, i) { return datum.label; }),
            datasets: [
                {
                    // copy all the relevant properties
                    backgroundColors: dataObject.datasets[0].backgroundColors,
                    chartType: dataObject.datasets[0].chartType,
                    label: dataObject.datasets[0].label,
                    // add our sorted data
                    data: sortedData
                }
            ]
        };
    };
    // If there isn't a chart already drawn in the container
    // This function is called and will do that
    PieChart.prototype.initialDraw = function () {
        this.setSVG();
        // need to draw the title for pie and donut before draw() so that it calculates the right
        // diameter for the graph to stay within the bounds
        this.drawTitle();
        // Add legend
        this.addOrUpdateLegend();
        // Draw slices & labels
        this.draw();
        // Add event listeners to slices
        this.addDataPointEventListener();
    };
    PieChart.prototype.draw = function () {
        var _this = this;
        var dataList = this.displayData.datasets[0].data;
        var chartSize = this.getChartSize(this.container);
        var diameter = Math.min(chartSize.width, chartSize.height);
        var radius = this.computeRadius();
        select(this.holder).select("svg")
            .attr("width", diameter + "px")
            .attr("height", diameter + "px");
        this.innerWrap
            .attr("transform", "translate(" + (radius + Configuration.pie.paddingLeft) + "," + radius + ")")
            .attr("width", diameter + "px")
            .attr("height", diameter + "px")
            .attr("preserveAspectRatio", "xMinYMin");
        // Compute the correct inner & outer radius
        var marginedRadius = this.computeRadius();
        this.arc = arc()
            .innerRadius(this.options.type === "donut" ? (marginedRadius * (3 / 4)) : 2)
            .outerRadius(marginedRadius);
        this.hoverArc = arc()
            .innerRadius(this.options.type === "donut" ? (marginedRadius * (3 / 4)) : 2)
            .outerRadius(marginedRadius + 3);
        this.pie = pie()
            .value(function (d) { return d.value; })
            .sort(null)
            .padAngle(0.007);
        // Draw the slices
        this.path = this.innerWrap.selectAll("path")
            .data(this.pie(dataList))
            .enter()
            .append("path")
            .attr("d", this.arc)
            .attr("fill", function (d) { return _this.getFillColor(_this.displayData.datasets[0].label, d.data.label, d.data.value); }) // Support multiple datasets
            .each(function (d) { this._current = d; });
        // Draw the slice labels
        var self = this;
        this.innerWrap
            .selectAll("text.chart-label")
            .data(this.pie(dataList), function (d) { return d.data.label; })
            .enter()
            .append("text")
            .classed("chart-label", true)
            .attr("dy", Configuration.pie.label.dy)
            .style("text-anchor", "middle")
            .text(function (d) { return self.getSliceLabelText(d.data.value, dataList); })
            .attr("transform", function (d) { return self.getChartLabelTranslateString(this, d, radius, dataList.length); });
        this.positionChart();
        // Hide overlay
        this.chartOverlay.hide();
    };
    // Interpolated transitions for older data points to reflect the new data changes
    PieChart.prototype.interpolateValues = function (newData) {
        var _this = this;
        var dataList = newData.datasets[0].data;
        // Apply the new data to the slices, and interpolate them
        var self = this;
        var path = this.innerWrap.selectAll("path").data(this.pie(dataList));
        // Update slices
        path
            .transition()
            .duration(0)
            .transition()
            .style("opacity", 1)
            .duration(Configuration.transitions.default.duration)
            .attr("fill", function (d) { return _this.getFillColor(_this.displayData.datasets[0].label, d.data.label, d.data.value); })
            .attrTween("d", function (a) {
            return arcTween.bind(this)(a, self.arc);
        });
        path.enter()
            .append("path")
            .attr("d", this.arc)
            .transition()
            .duration(0)
            .style("opacity", 0)
            .transition()
            .duration(Configuration.transitions.default.duration)
            .attr("fill", function (d) { return _this.getFillColor(_this.displayData.datasets[0].label, d.data.label, d.data.value); })
            .style("opacity", 1)
            .attrTween("d", function (a) {
            return arcTween.bind(this)(a, self.arc);
        });
        path
            .exit()
            .attr("d", this.arc)
            .transition()
            .duration(Configuration.transitions.default.duration)
            .style("opacity", 0)
            .remove();
        // Fade out all text labels
        this.innerWrap.selectAll("text.chart-label")
            .transition(self.getDefaultTransition("pie_chart_titles"))
            .style("opacity", 0)
            .transition(self.getDefaultTransition("pie_chart_titles"))
            .style("opacity", 1);
        // fade out left callout
        this.innerWrap.select("g.callout-lines-left")
            .transition(self.getDefaultTransition("pie_chart_titles"))
            .style("opacity", 0)
            .transition(self.getDefaultTransition("pie_chart_titles"))
            .style("opacity", 1);
        // fade out right callout
        this.innerWrap.select("g.callout-lines-right")
            .transition(self.getDefaultTransition("pie_chart_titles"))
            .style("opacity", 0)
            .transition(self.getDefaultTransition("pie_chart_titles"))
            .style("opacity", 1);
        // Move text labels to their new location, and fade them in again
        var radius = this.computeRadius();
        setTimeout(function () {
            var text = _this.innerWrap.selectAll("text.chart-label")
                .data(_this.pie(dataList), function (d) { return d.label; });
            text
                .enter()
                .append("text")
                .classed("chart-label", true)
                .attr("dy", Configuration.pie.label.dy)
                .style("text-anchor", "middle")
                .text(function (d) { return self.getSliceLabelText(d.data.value, dataList); })
                .attr("transform", function (d) { return self.getChartLabelTranslateString(this, d, radius, dataList.length); })
                .style("opacity", 0)
                .transition(_this.getDefaultTransition("pie_chart_titles"))
                .style("opacity", 1);
            text
                .style("text-anchor", "middle")
                .text(function (d) { return self.getSliceLabelText(d.data.value, dataList); })
                .attr("transform", function (d) { return self.getChartLabelTranslateString(this, d, radius); })
                .transition(_this.getDefaultTransition("pie_chart_titles"))
                .style("opacity", 1);
            text
                .exit()
                .remove();
        }, Configuration.transitions.pie_chart_titles.duration);
        // Add slice hover actions, and clear any slice borders present
        this.addDataPointEventListener();
        this.reduceOpacity();
        // Hide the overlay
        this.chartOverlay.hide();
    };
    // TODO - Possible inherits from base-chart
    PieChart.prototype.reduceOpacity = function (exception) {
        var _this = this;
        if (exception) {
            // this.innerWrap.selectAll("path").attr("fill-opacity", Configuration.charts.reduceOpacity.opacity);
            // Fade everything out except for this element
            select(exception).attr("fill-opacity", false);
            select(exception).attr("fill", function (d) { return _this.getFillColor(_this.displayData.datasets[0].label, d.data.label, d.data.value); });
        }
    };
    // TODO - Refactor
    PieChart.prototype.addDataPointEventListener = function () {
        var self = this;
        this.innerWrap.selectAll("path")
            .on("click", function (d) { return self.dispatchEvent("pie-slice-onClick", d); })
            .on("mouseover", function (d) {
            var sliceElement = select(this);
            Tools.moveToFront(sliceElement);
            sliceElement
                .transition(self.getDefaultTransition("pie_slice_hover"))
                .attr("d", self.hoverArc);
            self.showTooltip(d);
            self.reduceOpacity(this);
        })
            .on("mousemove", function (d) { return self.tooltip.positionTooltip(); })
            .on("mouseout", function (d) {
            select(this)
                .transition(self.getDefaultTransition("pie_slice_hover"))
                .attr("d", self.arc);
            self.hideTooltip();
        });
    };
    PieChart.prototype.update = function (newData) {
        var oldData = Tools.clone(this.displayData);
        var activeLegendItems = this.getActiveLegendItems();
        // TODO - Support multiple datasets
        var newDisplayData = Object.assign({}, oldData);
        newDisplayData.datasets[0].data = oldData.datasets[0].data.filter(function (dataPoint) { return activeLegendItems.indexOf(dataPoint.label) !== -1; });
        newDisplayData.labels = newDisplayData.datasets[0].data.map(function (datum) { return datum.label; });
        this.interpolateValues(newDisplayData);
    };
    PieChart.prototype.resizeChart = function () {
        var chartSize = this.getChartSize(this.container);
        var dimensionToUseForScale = Math.min(chartSize.width, chartSize.height);
        var radius = this.computeRadius();
        // Resize the SVG
        select(this.holder).select("svg")
            .attr("width", dimensionToUseForScale + "px")
            .attr("height", dimensionToUseForScale + "px");
        this.innerWrap
            .attr("transform", "translate(" + (radius + Configuration.pie.paddingLeft) + "," + radius + ")");
        // Resize the arcs
        this.arc = arc()
            .innerRadius(this.options.type === "donut" ? (radius * (3 / 4)) : 2)
            .outerRadius(radius);
        // Resize the arc
        this.hoverArc = arc()
            .innerRadius(this.options.type === "donut" ? (radius * (3 / 4)) : 2)
            .outerRadius(radius + 3);
        this.innerWrap.selectAll("path")
            .attr("d", this.arc);
        var self = this;
        // not using the actual data in case "Other" category functionality is present
        var totalSlices = this.innerWrap.selectAll("text.chart-label").size();
        this.innerWrap
            .selectAll("text.chart-label")
            .attr("transform", function (d) { return self.getChartLabelTranslateString(this, d, radius, totalSlices); });
        // Reposition the legend
        this.positionLegend();
        // position the entire chart after titles, legend and labels are added
        this.positionChart();
    };
    /**
     * The getChartSize function for pie and donut need to return the size of the
     * graph container while accounting for slice labels, callouts and a top legend.
     * Without accounting for padding, the pie/donut will try to use all space for the circle and labels fall outside.
     * @param container
     */
    PieChart.prototype.getChartSize = function (container) {
        var containerSize = _super.prototype.getChartSize.call(this, container);
        // if legend is on the top, we want the chart container to take that into account
        var legendHeight = this.container.select(".legend-wrapper").node().getBoundingClientRect().height;
        // padding for labels on top and below
        // accounting for callouts even when there are none so that the radius does not need to change on update
        var labelPadding = (Configuration.pie.label.fontSize * 2) + Configuration.pie.callout.calloutOffsetY;
        // to get the margin between slices and text/callouts, we convert the em value to pixels
        var textMargin = Configuration.pie.label.fontSize + +Configuration.pie.label.dy.replace(/[^0-9.,]+/, "");
        containerSize.height -= (legendHeight + labelPadding + (2 * textMargin));
        return containerSize;
    };
    // Helper functions
    PieChart.prototype.computeRadius = function () {
        var chartSize = this.getChartSize(this.container);
        var radius = Math.min(chartSize.width, chartSize.height) / 2;
        return radius;
    };
    /**
     * This positions the entire chart after it is drawn to account for the labels and callouts
     */
    PieChart.prototype.positionChart = function () {
        // align the chart to the top of the chart container OR legend if its on top
        var legendHeight = this.container.select(".legend-wrapper").node().getBoundingClientRect().height;
        // get the difference in position of the innerwrap to the chart container
        var containerPos = this.container.node().getBoundingClientRect().top;
        var innerWrapPos = this.innerWrap.node().getBoundingClientRect().top;
        var diff = innerWrapPos - containerPos;
        if (diff < 0) {
            // inner wrap to be just within the container at top
            diff = Math.abs(diff) + legendHeight;
        }
        else {
            // the innerwrap is aligned below
            diff = -diff + legendHeight;
        }
        // get current translations to add the additional difference
        var innerWrapTranslation = Tools.getTranslationValues(this.innerWrap.node());
        this.innerWrap
            .attr("transform", "translate(" + innerWrapTranslation.tx + ", " + (+innerWrapTranslation.ty + diff) + ")");
    };
    /**
     * Returns the string for the slice labels.
     * @param datapoint data value to get the percentage
     * @param dataset dataset containing all data values
     */
    PieChart.prototype.getSliceLabelText = function (datapoint, dataset) {
        return Tools.convertValueToPercentage(datapoint, dataset) + "%";
    };
    /**
     * Returns the translate string for the calculated position of the slice labels.
     * @param element the text label element
     * @param d the d3 slice object
     * @param radius the radius of the pie or donut chart
     * @param totalSlices total number of slices rendered
     */
    PieChart.prototype.getChartLabelTranslateString = function (element, d, radius, totalSlices) {
        var textLength = element.getComputedTextLength();
        var textOffsetX = textLength / 2;
        var textOffsetY = parseFloat(getComputedStyle(element).fontSize) / 2;
        var marginedRadius = radius + Configuration.pie.label.margin;
        var theta = ((d.endAngle - d.startAngle) / 2) + d.startAngle;
        var sliceAngleDeg = (d.endAngle - d.startAngle) * (180 / Math.PI);
        var xPosition = (textOffsetX + marginedRadius) * Math.sin(theta);
        var yPosition = (textOffsetY + marginedRadius) * -Math.cos(theta);
        if (!totalSlices) {
            return "translate(" + xPosition + ", " + yPosition + ")";
        }
        // check if last 2 slices (or just last) are < the threshold
        if (d.index === totalSlices - 1) {
            if (sliceAngleDeg < Configuration.pie.callout.sliceDegreeThreshold) {
                // start at the same location as a non-called out label
                var startPos = {
                    x: xPosition,
                    y: yPosition + textOffsetY
                };
                // end position for the callout line
                var endPos = {
                    x: xPosition + Configuration.pie.callout.calloutOffsetX,
                    y: yPosition - Configuration.pie.callout.calloutOffsetY + textOffsetY
                };
                // last slice always gets callout to the right side
                this.drawCallout(startPos, endPos, Configuration.pie.callout.direction.RIGHT);
                return "translate(" + (endPos.x + Configuration.pie.callout.calloutTextMargin + textOffsetX) + ",\n\t\t\t\t\t" + (yPosition - Configuration.pie.callout.calloutOffsetY) + ")";
            }
            // remove any unneeded callout for last slice
            this.removeCallout(Configuration.pie.callout.direction.RIGHT);
        }
        if (d.index === totalSlices - 2) {
            if (sliceAngleDeg < Configuration.pie.callout.sliceDegreeThreshold) {
                // start position for the callout line
                var startPos = {
                    x: xPosition,
                    y: yPosition + textOffsetY
                };
                // end position for the callout line should be bottom aligned to the title
                var endPos = {
                    x: xPosition - Configuration.pie.callout.calloutOffsetX,
                    y: yPosition - Configuration.pie.callout.calloutOffsetY + textOffsetY
                };
                this.drawCallout(startPos, endPos, Configuration.pie.callout.direction.LEFT);
                return "translate(" + (endPos.x - textOffsetX - Configuration.pie.callout.calloutTextMargin) + ",\n\t\t\t\t\t" + (yPosition - Configuration.pie.callout.calloutOffsetY) + ")";
            }
            // remove any leftover unneeded callout
            this.removeCallout(Configuration.pie.callout.direction.LEFT);
        }
        return "translate(" + xPosition + ", " + yPosition + ")";
    };
    /**
     * Removes the callout with the specified direction.
     * @param dir callout direction "right" or "left"
     */
    PieChart.prototype.removeCallout = function (dir) {
        this.innerWrap.select("g.callout-lines-" + dir).remove();
    };
    /**
     * Draws a line to the text label associated with the slice.
     * @param startPos x,y coordinate to start the callout line
     * @param endPos x,y coordinate to end the callout line
     * @param dir direction of callout (right/left)
     */
    PieChart.prototype.drawCallout = function (startPos, endPos, dir) {
        // Clean up the label callouts
        var callout = Tools.appendOrSelect(this.innerWrap, "g.callout-lines-" + dir);
        var intersectPointX = dir === Configuration.pie.callout.direction.RIGHT ?
            endPos.x - Configuration.pie.callout.horizontalLineLength :
            endPos.x + Configuration.pie.callout.horizontalLineLength;
        // draw vertical line
        var verticalLine = Tools.appendOrSelect(callout, "line.vertical-line");
        verticalLine
            .style("stroke-width", "1px")
            .attr("x1", startPos.x)
            .attr("y1", startPos.y)
            .attr("x2", intersectPointX)
            .attr("y2", endPos.y);
        // draw horizontal line
        var horizontalLine = Tools.appendOrSelect(callout, "line.horizontal-line");
        horizontalLine
            .style("stroke-width", "1px")
            .attr("x1", intersectPointX)
            .attr("y1", endPos.y)
            .attr("x2", endPos.x)
            .attr("y2", endPos.y);
    };
    return PieChart;
}(BaseChart));
export { PieChart };
// d3 Tween functions
function arcTween(a, arcFunc) {
    var _this = this;
    var i = interpolate(this._current, a);
    return function (t) {
        _this._current = i(t);
        return arcFunc(_this._current);
    };
}
//# sourceMappingURL=/home/travis/build/carbon-design-system/carbon-charts/packages/core/pie-chart.js.map