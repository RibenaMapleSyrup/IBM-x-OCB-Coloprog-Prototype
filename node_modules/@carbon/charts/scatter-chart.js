var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// D3 Imports
import { select } from "d3-selection";
import { BaseAxisChart } from "./base-axis-chart";
import * as Configuration from "./configuration";
import { ChartType } from "./configuration";
import { Tools } from "./tools";
var ScatterChart = /** @class */ (function (_super) {
    __extends(ScatterChart, _super);
    function ScatterChart(holder, configs) {
        var _this = _super.call(this, holder, configs) || this;
        _this.options = Tools.merge({}, Configuration.options.SCATTER);
        _this.options.type = ChartType.SCATTER;
        return _this;
    }
    ScatterChart.prototype.draw = function () {
        var _this = this;
        this.innerWrap.style("width", "100%")
            .style("height", "100%");
        var margins = Configuration.charts.margin.line;
        this.innerWrap.style("width", "100%").style("height", "100%");
        this.innerWrap.attr("transform", "translate(" + margins.left + ", " + margins.top + ")");
        var gDots = this.innerWrap.selectAll("g.dots")
            .data(this.displayData.datasets)
            .enter()
            .append("g")
            .classed("dots", true);
        var circleRadius = this.getCircleRadius();
        gDots.selectAll("circle.dot")
            .data(function (d, i) { return _this.addLabelsToDataPoints(d, i); })
            .enter()
            .append("circle")
            .attr("class", "dot")
            .attr("cx", function (d) { return _this.x(d.label) + _this.x.step() / 2; })
            .attr("cy", function (d) { return _this.y(d.value); })
            .attr("r", circleRadius)
            .attr("fill", function (d) { return _this.getCircleFill(circleRadius, d); })
            .attr("fill-opacity", function (d) { return _this.getCircleFillOpacity(); })
            .attr("stroke", function (d) { return _this.getStrokeColor(d.datasetLabel, d.label, d.value); });
        // Hide the overlay
        this.chartOverlay.hide();
        // Dispatch the load event
        this.dispatchEvent("load");
    };
    ScatterChart.prototype.getLegendType = function () {
        return Configuration.legend.basedOn.SERIES;
    };
    ScatterChart.prototype.addLabelsToDataPoints = function (d, index) {
        var labels = this.displayData.labels;
        return d.data.map(function (datum, i) { return ({
            label: labels[i],
            datasetLabel: d.label,
            value: datum
        }); });
    };
    ScatterChart.prototype.getCircleRadius = function () {
        return this.options.points.radius || Configuration.charts.points.radius;
    };
    ScatterChart.prototype.getCircleFill = function (radius, d) {
        // If the radius of the point is smaller than minimum
        // Or the chart is only a scatter chart
        // And not a line chart for instance
        var circleShouldBeFilled = radius < Configuration.lines.points.minNonFilledRadius || this.constructor === ScatterChart;
        if (circleShouldBeFilled) {
            return this.getStrokeColor(d.datasetLabel, d.label, d.value);
        }
        // returns null which discards any attribute allocations using return value
        return null;
    };
    ScatterChart.prototype.getCircleFillOpacity = function () {
        // If the chart is only a scatter chart
        // And not a line chart for instance
        if (this.constructor === ScatterChart) {
            return Configuration.options.SCATTER.points.fillOpacity;
        }
        return null;
    };
    ScatterChart.prototype.interpolateValues = function (newData) {
        var _this = this;
        var margins = Configuration.charts.margin.line;
        var chartSize = this.getChartSize();
        var width = chartSize.width - margins.left - margins.right;
        var height = chartSize.height - this.getBBox(".x.axis").height;
        // Apply new data to the lines
        var gDots = this.innerWrap.selectAll("g.dots")
            .data(newData.datasets);
        this.updateElements(true, gDots);
        // Add lines that need to be added now
        var addedDotGroups = gDots.enter()
            .append("g")
            .classed("dots", true);
        // Add line circles
        var circleRadius = this.getCircleRadius();
        addedDotGroups.selectAll("circle.dot")
            .data(function (d, i) { return _this.addLabelsToDataPoints(d, i); })
            .enter()
            .append("circle")
            .attr("class", "dot")
            .attr("cx", function (d, i) { return _this.x(d.label) + _this.x.step() / 2; })
            .attr("cy", function (d) { return _this.y(d.value); })
            .attr("r", circleRadius)
            .style("opacity", 0)
            .transition(this.getDefaultTransition())
            .style("opacity", 1)
            .attr("fill", function (d) { return _this.getCircleFill(circleRadius, d); })
            .attr("fill-opacity", function (d) { return _this.getCircleFillOpacity(); })
            .attr("stroke", function (d) { return _this.getStrokeColor(d.datasetLabel, d.label, d.value); });
        // Remove dots that are no longer needed
        gDots.exit()
            .classed("removed", true)
            .transition(this.getDefaultTransition())
            .style("opacity", 0)
            .remove();
        // Add slice hover actions, and clear any slice borders present
        this.addDataPointEventListener();
        // Hide the overlay
        this.chartOverlay.hide();
        // Dispatch the update event
        this.dispatchEvent("update");
    };
    ScatterChart.prototype.updateElements = function (animate, gDots) {
        var _this = this;
        if (!gDots) {
            gDots = this.innerWrap.selectAll("g.dots");
        }
        var transitionToUse = animate ? this.getFillTransition() : this.getInstantTransition();
        var self = this;
        var circleRadius = this.getCircleRadius();
        gDots.selectAll("circle.dot")
            .data(function (d, i) {
            var parentDatum = select(this).datum();
            return self.addLabelsToDataPoints(parentDatum, i);
        })
            .transition(transitionToUse)
            .attr("cx", function (d) { return _this.x(d.label) + _this.x.step() / 2; })
            .attr("cy", function (d) { return _this.y(d.value); })
            .attr("r", circleRadius)
            .attr("fill", function (d) { return _this.getCircleFill(circleRadius, d); })
            .attr("stroke", function (d) { return _this.getStrokeColor(d.datasetLabel, d.label, d.value); });
    };
    ScatterChart.prototype.resizeChart = function () {
        var chartSize = this.getChartSize(this.container);
        var dimensionToUseForScale = Math.min(chartSize.width, chartSize.height);
        // Resize the SVG
        select(this.holder).select("svg")
            .attr("width", dimensionToUseForScale + "px")
            .attr("height", dimensionToUseForScale + "px");
        this.updateXandYGrid(true);
        // Scale out the domains
        this.setXScale();
        this.setYScale();
        // Set the x & y axis as well as their labels
        this.setXAxis(true);
        this.setYAxis(true);
        this.updateElements(false, null);
        _super.prototype.resizeChart.call(this);
    };
    ScatterChart.prototype.setXScale = function () {
        _super.prototype.setXScale.call(this);
        this.x.padding(0); // override BaseAxisChart padding so points aren't misaligned by a few pixels.
    };
    ScatterChart.prototype.resetOpacity = function () {
        var _this = this;
        var circleRadius = this.getCircleRadius();
        this.innerWrap.selectAll("circle")
            .attr("stroke-opacity", Configuration.charts.resetOpacity.opacity)
            .attr("fill", function (d) { return _this.getCircleFill(circleRadius, d); });
    };
    ScatterChart.prototype.reduceOpacity = function (exception) {
        var _this = this;
        var circleRadius = this.getCircleRadius();
        select(exception).attr("fill-opacity", this.getCircleFillOpacity());
        select(exception).attr("stroke-opacity", Configuration.charts.reduceOpacity.opacity);
        select(exception).attr("fill", function (d) { return _this.getCircleFill(circleRadius, d); });
    };
    ScatterChart.prototype.addDataPointEventListener = function () {
        var self = this;
        var accessibility = this.options.accessibility;
        var circleRadius = this.getCircleRadius();
        this.svg.selectAll("circle.dot")
            .on("click", function (d) { return self.dispatchEvent("line-onClick", d); })
            .on("mouseover", function (d) {
            select(this)
                .attr("stroke-width", Configuration.lines.points.mouseover.strokeWidth)
                .attr("stroke", self.colorScale[d.datasetLabel](d.label))
                .attr("stroke-opacity", Configuration.lines.points.mouseover.strokeOpacity)
                .style("fill", self.colorScale[d.datasetLabel](d.label))
                .attr("fill-opacity", Configuration.lines.points.mouseover.fillOpacity);
            self.showTooltip(d, this);
        })
            .on("mousemove", function (d) { return self.tooltip.positionTooltip(); })
            .on("mouseout", function (d) {
            var _a = Configuration.lines.points.mouseout, strokeWidth = _a.strokeWidth, strokeWidthAccessible = _a.strokeWidthAccessible;
            select(this)
                .attr("stroke-width", accessibility ? strokeWidthAccessible : strokeWidth)
                .attr("stroke", self.colorScale[d.datasetLabel](d.label))
                .attr("stroke-opacity", Configuration.lines.points.mouseout.strokeOpacity)
                .style("fill", self.getCircleFill(circleRadius, d))
                .attr("fill-opacity", self.getCircleFillOpacity());
            self.hideTooltip();
        });
    };
    return ScatterChart;
}(BaseAxisChart));
export { ScatterChart };
//# sourceMappingURL=/home/travis/build/carbon-design-system/carbon-charts/packages/core/scatter-chart.js.map