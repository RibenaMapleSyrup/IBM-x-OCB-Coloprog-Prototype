var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// D3 Imports
import { select } from "d3-selection";
import { stack } from "d3-shape";
import { max } from "d3-array";
// Internal imports
import * as Configuration from "./configuration";
import { ChartType } from "./configuration";
import { BaseAxisChart } from "./base-axis-chart";
import { getBarWidth } from "./bar-chart";
// Add datasetLabel to each piece of data
// To be used to get the fill color
var addLabelsAndValueToData = function (d) {
    Object.keys(d).map(function (key) {
        if (typeof d[key] === "object") {
            d[key]["datasetLabel"] = d.key;
            d[key]["label"] = d[key].data["label"];
            d[key]["value"] = d[key].data[d.key];
        }
    });
    return d;
};
// TODO - Cleanup & add some comments
var StackedBarChart = /** @class */ (function (_super) {
    __extends(StackedBarChart, _super);
    function StackedBarChart(holder, configs) {
        var _this = _super.call(this, holder, configs) || this;
        _this.options.type = ChartType.BAR;
        return _this;
    }
    StackedBarChart.prototype.getYMax = function () {
        var _a = this.displayData, datasets = _a.datasets, labels = _a.labels;
        var scales = this.options.scales;
        var yMax;
        if (datasets.length === 1) {
            yMax = max(datasets[0].data);
        }
        else {
            yMax = max(labels.map(function (label, i) {
                var correspondingValues = datasets.map(function (dataset) { return dataset.data[i]; });
                var totalValue = correspondingValues.reduce(function (a, b) { return a + b; }, 0);
                return totalValue;
            }));
        }
        if (scales.y.yMaxAdjuster) {
            yMax = scales.y.yMaxAdjuster(yMax);
        }
        return yMax;
    };
    StackedBarChart.prototype.getStackData = function () {
        var _this = this;
        // Create the stack datalist
        var stackDataArray = this.displayData.labels.map(function (label, i) {
            var correspondingData = {};
            _this.displayData.datasets.forEach(function (dataset) {
                correspondingData[dataset.label] = dataset.data[i];
            });
            correspondingData["label"] = label;
            return correspondingData;
        });
        return stackDataArray;
    };
    // currently unused, but required to match the BarChart class
    StackedBarChart.prototype.getBarX = function (d) {
        var barWidth = getBarWidth(this);
        var paddingDeductions = (Configuration.scales.x.padding * this.x.bandwidth()) / 2;
        return this.x(d.data.label) + (this.x.step() / 2) - (barWidth / 2) - paddingDeductions;
    };
    StackedBarChart.prototype.draw = function () {
        var _this = this;
        this.innerWrap.style("width", "100%")
            .style("height", "100%");
        var margins = Configuration.charts.margin.bar;
        this.innerWrap
            .attr("transform", "translate(" + margins.left + ", " + margins.top + ")");
        var stackDataArray = this.getStackData();
        var stackKeys = this.displayData.datasets.map(function (dataset) { return dataset.label; });
        this.innerWrap.append("g")
            .classed("bars-wrapper", true)
            .selectAll("g")
            .data(stack().keys(stackKeys)(stackDataArray))
            .enter()
            .append("g")
            .classed("bars", true)
            .selectAll("rect")
            .data(function (d) { return addLabelsAndValueToData(d); })
            .enter()
            .append("rect")
            .classed("bar", true)
            .attr("x", this.getBarX.bind(this))
            .attr("y", function (d) { return _this.y(d[1]); })
            .attr("height", function (d) { return _this.y(d[0]) - _this.y(d[1]); })
            .attr("width", function () { return getBarWidth(_this); })
            .attr("fill", function (d) { return _this.getFillColor(d.datasetLabel, d.data.label, d.data.value); })
            .attr("stroke", function (d) { return _this.options.accessibility ? _this.getStrokeColor(d.datasetLabel, d.label, d.value) : null; })
            .attr("stroke-width", Configuration.bars.default.strokeWidth)
            .attr("stroke-opacity", function (d) { return _this.options.accessibility ? 1 : 0; });
        // Hide the overlay
        this.chartOverlay.hide();
        // Dispatch the load event
        this.dispatchEvent("load");
    };
    StackedBarChart.prototype.interpolateValues = function (newData) {
        var _this = this;
        var stackDataArray = this.getStackData();
        var stackKeys = this.displayData.datasets.map(function (dataset) { return dataset.label; });
        this.innerWrap.selectAll(".removed")
            .remove();
        var g = this.innerWrap.selectAll("g.bars-wrapper")
            .selectAll("g")
            .data(stack().keys(stackKeys)(stackDataArray));
        var rect = g.selectAll("rect.bar")
            .data(function (d) { return addLabelsAndValueToData(d); });
        this.updateElements(true, g.selectAll("rect.bar"), g);
        var addRect = function (selection) {
            selection.enter()
                .append("rect")
                .classed("bar", true)
                .attr("x", _this.getBarX.bind(_this))
                .attr("y", function (d) { return _this.y(d[1]); })
                .attr("height", function (d) { return _this.y(d[0]) - _this.y(d[1]); })
                .attr("width", function () { return getBarWidth(_this); })
                .attr("fill", function (d) { return _this.getFillColor(d.datasetLabel, d.data.label, d.data.value); })
                .style("opacity", 0)
                .transition(_this.getFillTransition())
                .style("opacity", 1)
                .attr("stroke", function (d) { return _this.options.accessibility ? _this.getStrokeColor(d.datasetLabel, d.label, d.value) : null; })
                .attr("stroke-width", Configuration.bars.default.strokeWidth)
                .attr("stroke-opacity", function (d) { return _this.options.accessibility ? 1 : 0; });
        };
        var rectsToAdd = g.enter()
            .append("g")
            .classed("bars", true)
            .selectAll("rect")
            .data(function (d) { return addLabelsAndValueToData(d); });
        addRect(rectsToAdd);
        addRect(rect);
        g.exit()
            .classed("removed", true) // mark this element with "removed" class so it isn't reused
            .transition(this.getDefaultTransition())
            .style("opacity", 0)
            .remove();
        rect.exit()
            .classed("removed", true) // mark this element with "removed" class so it isn't reused
            .transition(this.getDefaultTransition())
            .style("opacity", 0)
            .remove();
        // Add slice hover actions, and clear any slice borders present
        this.addDataPointEventListener();
        // Hide the overlay
        this.chartOverlay.hide();
        // Dispatch the update event
        this.dispatchEvent("update");
    };
    StackedBarChart.prototype.resizeChart = function () {
        var actualChartSize = this.getChartSize(this.container);
        var dimensionToUseForScale = Math.min(actualChartSize.width, actualChartSize.height);
        // Resize the SVG
        select(this.holder).select("svg")
            .attr("width", dimensionToUseForScale + "px")
            .attr("height", dimensionToUseForScale + "px");
        this.updateXandYGrid(true);
        // Scale out the domains
        this.setXScale();
        this.setYScale();
        // Set the x & y axis as well as their labels
        this.setXAxis(true);
        this.setYAxis(true);
        // Apply new data to the bars
        var g = this.innerWrap.selectAll("g.bars g");
        this.updateElements(false, null, g);
        _super.prototype.resizeChart.call(this);
    };
    StackedBarChart.prototype.updateElements = function (animate, rect, g) {
        var _this = this;
        if (!rect) {
            rect = this.innerWrap.selectAll("rect.bar");
        }
        // Update existing bars
        rect
            .transition(animate ? this.getFillTransition() : this.getInstantTransition())
            .style("opacity", 1)
            .attr("x", this.getBarX.bind(this))
            .attr("y", function (d) { return _this.y(d[1]); })
            .attr("height", function (d) { return _this.y(d[0]) - _this.y(d[1]); })
            .attr("width", function () { return getBarWidth(_this); })
            .attr("fill", function (d) { return _this.getFillColor(d.datasetLabel, d.data.label, d.data.value); })
            .attr("stroke", function (d) { return _this.options.accessibility ? _this.getStrokeColor(d.datasetLabel, d.label, d.value) : null; })
            .attr("stroke-width", Configuration.bars.default.strokeWidth)
            .attr("stroke-opacity", function (d) { return _this.options.accessibility ? 1 : 0; });
    };
    StackedBarChart.prototype.addDataPointEventListener = function () {
        var self = this;
        var accessibility = this.options.accessibility;
        this.svg.selectAll("rect.bar")
            .on("click", function (d) { return self.dispatchEvent("bar-onClick", d); })
            .on("mouseover", function (d) {
            select(this)
                .attr("stroke-width", Configuration.bars.mouseover.strokeWidth)
                .attr("stroke", self.getStrokeColor(d.datasetLabel, d.label, d.value))
                .attr("stroke-opacity", Configuration.bars.mouseover.strokeOpacity);
            self.showTooltip(d, this);
            self.reduceOpacity(this);
        })
            .on("mousemove", function (d) { return self.tooltip.positionTooltip(); })
            .on("mouseout", function (d) {
            var _a = Configuration.bars.mouseout, strokeWidth = _a.strokeWidth, strokeWidthAccessible = _a.strokeWidthAccessible;
            select(this)
                .attr("stroke-width", accessibility ? strokeWidthAccessible : strokeWidth)
                .attr("stroke", accessibility ? self.getStrokeColor(d.datasetLabel, d.label, d.value) : "none")
                .attr("stroke-opacity", Configuration.bars.mouseout.strokeOpacity);
            self.hideTooltip();
        });
    };
    return StackedBarChart;
}(BaseAxisChart));
export { StackedBarChart };
//# sourceMappingURL=/home/travis/build/carbon-design-system/carbon-charts/packages/core/stacked-bar-chart.js.map