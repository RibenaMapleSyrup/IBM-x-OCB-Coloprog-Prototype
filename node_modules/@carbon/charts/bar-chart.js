var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// D3 Imports
import { select } from "d3-selection";
import { scaleBand } from "d3-scale";
import { min } from "d3-array";
import { BaseAxisChart } from "./base-axis-chart";
import { StackedBarChart } from "./stacked-bar-chart";
import * as Configuration from "./configuration";
import { ChartType } from "./configuration";
import { Tools } from "./tools";
var getYMin = function (configs) {
    var datasets = configs.data.datasets;
    var scales = configs.options.scales;
    var yMin;
    if (datasets.length === 1) {
        yMin = min(datasets[0].data);
    }
    else {
        yMin = min(datasets, function (d) { return (min(d.data)); });
    }
    if (scales.y.yMinAdjuster) {
        yMin = scales.y.yMinAdjuster(yMin);
    }
    return yMin;
};
// returns the configured max width or the calculated bandwidth
// whichever is lower
// defaults to the calculated bandwidth if no maxWidth is defined
export var getBarWidth = function (chart) {
    var width = Tools.getProperty(chart.options, "bars", "width");
    var maxWidth = Tools.getProperty(chart.options, "bars", "maxWidth");
    var currentBandWidth = chart.x.bandwidth();
    if (width) {
        if (maxWidth) {
            if (width <= maxWidth) {
                return width;
            }
            return maxWidth;
        }
        return width;
    }
    if (!maxWidth) {
        return currentBandWidth;
    }
    if (currentBandWidth <= maxWidth) {
        return currentBandWidth;
    }
    return maxWidth;
};
// returns true if the calculated bandwidth is greater than the maxWidth (if defined)
// i.e. if we should be constraining ourselves to a specific bar width
export var isWidthConstrained = function (chart) {
    var maxWidth = Tools.getProperty(chart.options, "bars", "maxWidth");
    var currentBandWidth = chart.x.bandwidth();
    if (!maxWidth) {
        return false;
    }
    if (currentBandWidth <= maxWidth) {
        return false;
    }
    return true;
};
var BarChart = /** @class */ (function (_super) {
    __extends(BarChart, _super);
    function BarChart(holder, configs) {
        var _this = this;
        // If this is a stacked bar chart, change the object prototype
        if (configs.options.scales.y.stacked) {
            if (getYMin(configs) >= 0) {
                return new StackedBarChart(holder, configs);
            }
            else {
                console.error("Negative values are not supported in StackedBarChart, using GroupedBarChart instead to render!");
            }
        }
        _this = _super.call(this, holder, configs) || this;
        // initialize options
        if (configs.options) {
            _this.options = Tools.merge({}, Configuration.options.BAR, configs.options);
        }
        else {
            _this.options = Tools.merge({}, Configuration.options.BAR);
        }
        // To be used for combo chart instances of a bar chart
        var axis = configs.options.axis;
        if (axis) {
            var margins = Configuration.charts.margin.bar;
            var chartSize = _this.getChartSize();
            var width = chartSize.width - margins.left - margins.right;
            _this.x1 = scaleBand().rangeRound([0, width]).padding(Configuration.bars.spacing.bars);
            _this.x1.domain(_this.data.datasets.map(function (dataset) { return dataset.label; }))
                .rangeRound([0, getBarWidth(_this)]);
        }
        _this.options.type = ChartType.BAR;
        return _this;
    }
    BarChart.prototype.setXScale = function (xScale) {
        var margins = Configuration.charts.margin.bar;
        var chartSize = this.getChartSize();
        var width = chartSize.width - margins.left - margins.right;
        if (xScale) {
            this.x = xScale;
        }
        else {
            this.x = scaleBand().rangeRound([0, width]).padding(Configuration.bars.spacing.datasets);
            this.x.domain(this.displayData.labels);
        }
        // if it's a grouped bar, use additoinal padding so the bars don't group up
        if (this.displayData.datasets.length > 1) {
            this.x1 = scaleBand().rangeRound([0, width]).padding(Configuration.bars.spacing.bars);
        }
        else {
            this.x1 = scaleBand().rangeRound([0, width]);
        }
        this.x1.domain(this.displayData.datasets.map(function (dataset) { return dataset.label; }))
            .rangeRound([0, getBarWidth(this)]);
    };
    BarChart.prototype.getBarX = function (d) {
        if (!isWidthConstrained(this)) {
            return this.x1(d.datasetLabel);
        }
        return (this.x.bandwidth() / 2) - (Tools.getProperty(this.options, "bars", "maxWidth") / 2);
    };
    BarChart.prototype.draw = function () {
        var _this = this;
        this.innerWrap.style("width", "100%")
            .style("height", "100%");
        var margins = Configuration.charts.margin.bar;
        var chartSize = this.getChartSize();
        var width = chartSize.width - margins.left - margins.right;
        var height = chartSize.height - this.getBBox(".x.axis").height;
        var gBars = this.innerWrap
            .attr("transform", "translate(" + margins.left + ", " + margins.top + ")")
            .append("g")
            .classed("bars", true)
            .attr("width", width);
        gBars.selectAll("g")
            .data(this.displayData.labels)
            .enter()
            .append("g")
            .attr("transform", function (d) { return "translate(" + _this.x(d) + ", 0)"; })
            .selectAll("rect.bar")
            .data(function (d, index) { return _this.addLabelsToDataPoints(d, index); })
            .enter()
            .append("rect")
            .classed("bar", true)
            .attr("x", this.getBarX.bind(this))
            .attr("y", function (d) { return _this.y(Math.max(0, d.value)); })
            .attr("width", this.x1.bandwidth())
            .attr("height", function (d) { return Math.abs(_this.y(d.value) - _this.y(0)); })
            .attr("fill", function (d) { return _this.getFillColor(d.datasetLabel, d.label, d.value); })
            .attr("stroke", function (d) { return _this.options.accessibility ? _this.getStrokeColor(d.datasetLabel, d.label, d.value) : null; })
            .attr("stroke-width", Configuration.bars.default.strokeWidth)
            .attr("stroke-opacity", function (d) { return _this.options.accessibility ? 1 : 0; });
        // Hide the overlay
        this.chartOverlay.hide();
        // Dispatch the load event
        this.dispatchEvent("load");
    };
    BarChart.prototype.interpolateValues = function (newData) {
        var _this = this;
        var margins = Configuration.charts.margin.bar;
        var chartSize = this.getChartSize();
        var width = chartSize.width - margins.left - margins.right;
        var height = chartSize.height - this.getBBox(".x.axis").height;
        // Apply new data to the bars
        var g = this.innerWrap.select("g.bars")
            .attr("width", width)
            .selectAll("g")
            .data(this.displayData.labels);
        var rect = g.selectAll("rect.bar")
            .data(function (d, index) { return _this.addLabelsToDataPoints(d, index); });
        this.updateElements(true, rect, g);
        // Add bar groups that need to be added now
        var addedBars = g.enter()
            .append("g")
            .classed("bars", true)
            .attr("transform", function (d) { return "translate(" + _this.x(d) + ", 0)"; });
        // Add bars that need to be added now
        g.selectAll("rect.bar")
            .data(function (d, index) { return _this.addLabelsToDataPoints(d, index); })
            .enter()
            .append("rect")
            .attr("class", "bar")
            .attr("x", this.getBarX.bind(this))
            .attr("y", function (d) { return _this.y(Math.max(0, d.value)); })
            .attr("width", this.x1.bandwidth())
            .attr("height", function (d) { return Math.abs(_this.y(d.value) - _this.y(0)); })
            .style("opacity", 0)
            .transition(this.getFillTransition())
            .attr("fill", function (d) { return _this.getFillColor(d.datasetLabel, d.label, d.value); })
            .style("opacity", 1)
            .attr("stroke", function (d) { return _this.getStrokeColor(d.datasetLabel, d.label, d.value); })
            .attr("stroke-width", Configuration.bars.default.strokeWidth);
        addedBars.selectAll("rect.bar")
            .data(function (d, index) { return _this.addLabelsToDataPoints(d, index); })
            .enter()
            .append("rect")
            .attr("class", "bar")
            .attr("x", this.getBarX.bind(this))
            .attr("y", function (d) { return _this.y(Math.max(0, d.value)); })
            .attr("width", this.x1.bandwidth())
            .attr("height", function (d) { return Math.abs(_this.y(d.value) - _this.y(0)); })
            .style("opacity", 0)
            .transition(this.getFillTransition())
            .attr("fill", function (d) { return _this.getFillColor(d.datasetLabel, d.label, d.value); })
            .style("opacity", 1)
            .attr("stroke", function (d) { return _this.getStrokeColor(d.datasetLabel, d.label, d.value); })
            .attr("stroke-width", Configuration.bars.default.strokeWidth);
        // Remove bar groups are no longer needed
        g.exit()
            .transition(this.getDefaultTransition())
            .style("opacity", 0)
            .remove();
        // Remove bars that are no longer needed
        rect.exit()
            .transition(this.getDefaultTransition())
            .style("opacity", 0)
            .remove();
        // Add slice hover actions, and clear any slice borders present
        this.addDataPointEventListener();
        // Hide the overlay
        this.chartOverlay.hide();
        // Dispatch the update event
        this.dispatchEvent("update");
    };
    BarChart.prototype.updateElements = function (animate, rect, g) {
        var _this = this;
        if (!rect) {
            rect = this.innerWrap.selectAll("rect.bar");
        }
        if (g) {
            g.transition(animate ? this.getDefaultTransition() : this.getInstantTransition())
                .attr("transform", function (d) { return "translate(" + _this.x(d) + ", 0)"; })
                .style("opacity", 1);
        }
        // Update existing bars
        rect
            .transition(animate ? this.getFillTransition() : this.getInstantTransition())
            .style("opacity", 1)
            .attr("x", this.getBarX.bind(this))
            .attr("y", function (d) { return _this.y(Math.max(0, d.value)); })
            .attr("width", this.x1.bandwidth())
            .attr("height", function (d) { return Math.abs(_this.y(d.value) - _this.y(0)); })
            .attr("fill", function (d) { return _this.getFillColor(d.datasetLabel, d.label, d.value); })
            .attr("stroke", function (d) { return _this.options.accessibility ? _this.getStrokeColor(d.datasetLabel, d.label, d.value) : null; });
    };
    BarChart.prototype.resizeChart = function () {
        var actualChartSize = this.getChartSize(this.container);
        var dimensionToUseForScale = Math.min(actualChartSize.width, actualChartSize.height);
        // Resize the SVG
        select(this.holder).select("svg")
            .attr("width", dimensionToUseForScale + "px")
            .attr("height", dimensionToUseForScale + "px");
        this.updateXandYGrid(true);
        // Scale out the domains
        this.setXScale();
        this.setYScale();
        // Set the x & y axis as well as their labels
        this.setXAxis(true);
        this.setYAxis(true);
        // Apply new data to the bars
        var g = this.innerWrap.selectAll("g.bars g");
        this.updateElements(false, null, g);
        _super.prototype.resizeChart.call(this);
    };
    BarChart.prototype.addDataPointEventListener = function () {
        var _this = this;
        var self = this;
        var accessibility = this.options.accessibility;
        this.svg.selectAll("rect.bar")
            .on("click", function (d) { return self.dispatchEvent("bar-onClick", d); })
            .on("mouseover", function (d) {
            select(this)
                .attr("stroke-width", Configuration.bars.mouseover.strokeWidth)
                .attr("stroke", self.getStrokeColor(d.datasetLabel, d.label, d.value))
                .attr("stroke-opacity", Configuration.bars.mouseover.strokeOpacity);
            self.showTooltip(d, this);
            self.reduceOpacity(this);
        })
            .on("mousemove", function (d) { return _this.tooltip.positionTooltip(); })
            .on("mouseout", function (d) {
            var _a = Configuration.bars.mouseout, strokeWidth = _a.strokeWidth, strokeWidthAccessible = _a.strokeWidthAccessible;
            select(this)
                .attr("stroke-width", accessibility ? strokeWidthAccessible : strokeWidth)
                .attr("stroke", accessibility ? self.getStrokeColor(d.datasetLabel, d.label, d.value) : "none")
                .attr("stroke-opacity", Configuration.bars.mouseout.strokeOpacity);
            self.hideTooltip();
        });
    };
    return BarChart;
}(BaseAxisChart));
export { BarChart };
//# sourceMappingURL=/home/travis/build/carbon-design-system/carbon-charts/packages/core/bar-chart.js.map