// D3 Imports
import { event, mouse, select, selectAll } from "d3-selection";
import { scaleOrdinal } from "d3-scale";
import { transition } from "d3-transition";
// Internal Imports
import * as Configuration from "./configuration";
import { Tools } from "./tools";
import PatternsService from "./services/patterns";
import { ChartOverlay } from "./components/index";
import { ChartTooltip } from "./components/tooltip";
// Misc
import ResizeObserver from "resize-observer-polyfill";
var BaseChart = /** @class */ (function () {
    function BaseChart(holder, configs) {
        var _this = this;
        this.id = "";
        this.chartContainerID = "";
        this.options = Tools.merge({}, Configuration.options.BASE);
        // Fill scales & fill related objects
        this.patternScale = {};
        this.colorScale = {};
        this.eventHandlers = {
            tooltips: null
        };
        this.getTooltipHTML = function (d) {
            var formattedValue = _this.options.tooltip.formatter ? _this.options.tooltip.formatter(d.value) : d.value.toLocaleString("en");
            if (_this.getLegendType() === Configuration.legend.basedOn.LABELS) {
                return _this.generateTooltipHTML(d.label, formattedValue);
            }
            return _this.generateTooltipHTML(d.datasetLabel, formattedValue);
        };
        this.id = "chart-" + BaseChart.chartCount++;
        if (configs.options) {
            this.options = Tools.merge({}, this.options, configs.options);
        }
        // Save holder element reference, and initialize it by applying appropriate styling
        this.holder = holder;
        this.styleHolderElement();
        var _a = this.setChartIDContainer(), chartId = _a.chartId, container = _a.container;
        this.container = container;
        this.chartContainerID = chartId;
        if (this.options.containerResizable) {
            this.resizeWhenContainerChange();
        }
        this.events = document.createDocumentFragment();
        // Initialize charting components
        this.chartOverlay = new ChartOverlay(this.holder, this.options.overlay);
        this.tooltip = new ChartTooltip(this.container.node());
        if (configs.data) {
            this.setData(configs.data);
        }
    }
    BaseChart.prototype.styleHolderElement = function () {
        var holderElement = this.holder;
        var _a = this.options, width = _a.width, height = _a.height;
        // Add class to chart holder
        select(this.holder).classed("chart-holder", true);
        // If width exists in options
        if (width) {
            // Apply formatted width attribute to chart
            holderElement.style.width = Tools.formatWidthHeightValues(width);
        }
        // If height exists in options
        if (height) {
            // Apply formatted height attribute to chart
            holderElement.style.height = Tools.formatWidthHeightValues(height);
        }
    };
    BaseChart.prototype.dispatchEvent = function (eventType, eventDetail) {
        var newEvent;
        if (eventDetail) {
            newEvent = new CustomEvent(eventType, {
                detail: eventDetail
            });
        }
        else {
            newEvent = document.createEvent("Event");
            newEvent.initEvent(eventType, false, true);
        }
        this.events.dispatchEvent(newEvent);
    };
    BaseChart.prototype.setData = function (data) {
        var _this = this;
        var initialDraw = !this.innerWrap;
        var newDataIsAPromise = Promise.resolve(data) === data;
        // Dispatch the update event
        this.dispatchEvent("data-change");
        if (initialDraw || newDataIsAPromise) {
            this.chartOverlay.show();
        }
        // Hide current showing tooltip
        if (!initialDraw) {
            this.hideTooltip();
        }
        Promise.resolve(data).then(function (value) {
            // Dispatch the update event
            _this.dispatchEvent("data-load");
            // Process data
            // this.data = this.dataProcessor(Tools.clone(value));
            _this.data = Tools.clone(value);
            if (_this.data.datasets && _this.data.datasets.length > 0) {
                _this.displayData = _this.dataProcessor(Tools.clone(value));
                var keys = _this.getKeysFromData();
                // Grab the old legend items, the keys from the current data
                // Compare the two, if there are any differences (additions/removals)
                // Completely remove the legend and render again
                var oldLegendItems = _this.getActiveLegendItems();
                var keysArray = Object.keys(keys);
                var _a = Tools.arrayDifferences(oldLegendItems, keysArray), removedItems = _a.missing, newItems = _a.added;
                // Update keys for legend use the latest data keys
                _this.options.keys = keys;
                // Set the color scale based on the keys present in the data
                _this.setColorScale();
                // Add patterns to page, set pattern scales
                if (_this.options.accessibility) {
                    _this.setPatterns();
                }
                // Perform the draw or update chart
                if (initialDraw) {
                    _this.initialDraw();
                }
                else {
                    if (removedItems.length > 0 || newItems.length > 0) {
                        _this.addOrUpdateLegend();
                    }
                    _this.update();
                }
                _this.drawTitle();
            }
            else {
                _this.chartOverlay.show(Configuration.options.BASE.overlay.types.noData);
            }
        });
    };
    BaseChart.prototype.getKeysFromData = function () {
        var _this = this;
        var keys = {};
        if (this.getLegendType() === Configuration.legend.basedOn.LABELS) {
            // Build out the keys array of objects to represent the legend items
            this.displayData.labels.forEach(function (label) {
                keys[label] = Configuration.legend.items.status.ACTIVE;
            });
        }
        else {
            this.displayData.datasets.forEach(function (dataset) {
                keys[dataset.label] = Configuration.legend.items.status.ACTIVE;
            });
        }
        // Apply disabled legend items from previous data
        // That also are applicable to the new data
        var disabledLegendItems = this.getDisabledLegendItems();
        Object.keys(keys).forEach(function (key) {
            if (disabledLegendItems.indexOf(key) !== -1) {
                keys[key] = Configuration.legend.items.status.DISABLED;
            }
        });
        if (!this.fixedDataLabels) {
            this.fixedDataLabels = this.displayData.labels;
        }
        else {
            this.displayData.labels.forEach(function (element) {
                if (_this.fixedDataLabels.indexOf(element) === -1) {
                    _this.fixedDataLabels.push(element);
                }
            });
        }
        return keys;
    };
    BaseChart.prototype.getLegendType = function () {
        var datasets = this.displayData.datasets;
        // TODO - Support the labels based legend for line chart
        if (datasets.length === 1 && datasets[0].backgroundColors && datasets[0].backgroundColors.length > 1) {
            return Configuration.legend.basedOn.LABELS;
        }
        else {
            return Configuration.legend.basedOn.SERIES;
        }
    };
    BaseChart.prototype.setPatterns = function () {
        var _this = this;
        // Accessibility & patterns
        this.patternsService = new PatternsService();
        this.patternsService.addPatternSVGs(this.displayData, this.colorScale, this.chartContainerID, this.getLegendType());
        var patternURLs = this.patternsService.getFillValues();
        Object.keys(patternURLs).forEach(function (datasetLabel) {
            _this.patternScale[datasetLabel] = scaleOrdinal()
                .range(patternURLs[datasetLabel])
                .domain(_this.getLegendItemKeys());
        });
    };
    BaseChart.prototype.setColorScale = function () {
        var _this = this;
        if (this.displayData.datasets[0].backgroundColors) {
            this.displayData.datasets.forEach(function (dataset) {
                _this.colorScale[dataset.label] = scaleOrdinal().range(dataset.backgroundColors).domain(_this.fixedDataLabels);
            });
        }
        else {
            var colors_1 = Configuration.options.BASE.colors;
            this.displayData.datasets.forEach(function (dataset, i) {
                _this.colorScale[dataset.label] = scaleOrdinal().range([colors_1[i]]).domain(_this.fixedDataLabels);
            });
        }
    };
    BaseChart.prototype.getFillColor = function (datasetLabel, label, value) {
        if (this.options.getFillColor && !this.options.accessibility) {
            return this.options.getFillColor(datasetLabel, label, value) || this.getFillScale()[datasetLabel](label);
        }
        else {
            return this.getFillScale()[datasetLabel](label);
        }
    };
    BaseChart.prototype.getStrokeColor = function (datasetLabel, label, value) {
        if (this.options.getStrokeColor) {
            return this.options.getStrokeColor(datasetLabel, label, value) || this.colorScale[datasetLabel](label);
        }
        else {
            return this.colorScale[datasetLabel](label);
        }
    };
    // TODO - Refactor
    BaseChart.prototype.getChartSize = function (container) {
        if (container === void 0) { container = this.container; }
        var ratio, marginForLegendTop, marginForChartTitle;
        if (container.node().clientWidth > Configuration.charts.widthBreak) {
            ratio = Configuration.charts.magicRatio;
            marginForLegendTop = 0;
        }
        else {
            marginForLegendTop = Configuration.charts.marginForLegendTop;
            ratio = 1;
        }
        // Store computed actual size, to be considered for change if chart does not support axis
        var marginsToExclude = 0;
        var titleRef = container.select("text.chart-title");
        marginForChartTitle = titleRef.empty() ? 0 : this.svg.select("text.chart-title").node().getBoundingClientRect().height;
        var computedChartSize = {
            height: container.node().clientHeight - marginForLegendTop - marginForChartTitle,
            width: (container.node().clientWidth - marginsToExclude) * ratio
        };
        // If chart is of type pie or donut, width and height should equal to the min of the width and height computed
        var maxSizePossible = Math.min(computedChartSize.height, computedChartSize.width);
        maxSizePossible = Math.max(maxSizePossible, Configuration.charts.minWidth);
        return {
            height: maxSizePossible,
            width: maxSizePossible
        };
    };
    /*
     * removes the chart and any tooltips
     */
    BaseChart.prototype.removeChart = function () {
        // this.holder.remove();
        this.holder.querySelector("div.chart-wrapper").parentNode.removeChild(this.holder.querySelector("div.chart-wrapper"));
    };
    BaseChart.prototype.setSVG = function () {
        var chartSize = this.getChartSize();
        this.svg = this.container.append("svg")
            .classed("chart-svg " + this.options.type, true);
        this.innerWrap = this.svg.append("g")
            .classed("inner-wrap", true);
        return this.svg;
    };
    // Default fallback when no data processing is needed
    BaseChart.prototype.dataProcessor = function (data) {
        return data;
    };
    /*
     * called when the chart needs to be drawn initially
     */
    BaseChart.prototype.initialDraw = function () {
        console.warn("You should implement your own `initialDraw()` function.");
    };
    BaseChart.prototype.updateChart = function () {
        console.warn("You should implement your own `updateChart()` function.");
    };
    BaseChart.prototype.resizeChart = function () {
        console.warn("You should implement your own `resizeChart()` function.");
    };
    BaseChart.prototype.update = function (value) {
        console.warn("You should implement your own `update()` function.");
    };
    BaseChart.prototype.resizeWhenContainerChange = function () {
        var _this = this;
        var containerWidth = this.holder.clientWidth;
        var containerHeight = this.holder.clientHeight;
        var resizeObserver = new ResizeObserver(function (entries, observer) {
            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                var entry = entries_1[_i];
                if (Math.abs(containerWidth - _this.holder.clientWidth) > 1
                    || Math.abs(containerHeight - _this.holder.clientHeight) > 1) {
                    containerWidth = _this.holder.clientWidth;
                    containerHeight = _this.holder.clientHeight;
                    selectAll(".legend-tooltip").style("display", "none");
                    _this.hideTooltip();
                    _this.resizeChart();
                    _this.drawTitle();
                }
            }
        });
        resizeObserver.observe(this.holder);
    };
    /**
     * Draws title within the Chart's svg element.
     * @param title
     */
    BaseChart.prototype.drawTitle = function () {
        if (this.options.title) {
            // adds title or gets reference to title
            var titleRef = Tools.appendOrSelect(this.svg, "text.chart-title");
            titleRef.text(this.options.title);
            // position of the title element
            var titlePos = titleRef.node().getBoundingClientRect().bottom;
            // the translations on the inner wrap and the current position
            var translateObj = Tools.getTranslationValues(this.innerWrap.node());
            var innerWrapPos = this.innerWrap.node().getBoundingClientRect().top;
            // check that the inner wrap is below the title text
            var diff = innerWrapPos - titlePos;
            if (diff < 0) {
                // we want the inner wrap to be under the title and add some padding
                diff = Math.abs(diff) + Configuration.charts.title.marginBottom;
            }
            else {
                // the innerwrap is below the title, we assert the title bottom padding
                if (diff < Configuration.charts.title.marginBottom) {
                    diff = Configuration.charts.title.marginBottom - diff;
                }
                else {
                    // does not need to move
                    return;
                }
            }
            this.innerWrap
                .attr("transform", "translate(" + translateObj.tx + ", " + (+translateObj.ty + diff) + ")");
        }
    };
    BaseChart.prototype.setClickableLegend = function () {
        var self = this;
        var c = select(this.holder);
        if (this.getActiveLegendItems().length === 1) {
            c.selectAll(".legend-btn.active").classed("not-allowed", true);
        }
        // Add hover effect for legend item circles
        self.addLegendCircleHoverEffect();
        c.selectAll(".legend-btn").each(function () {
            select(this).classed("clickable", true);
            select(this).on("click", function () {
                c.selectAll(".chart-tooltip").remove();
                c.selectAll(".label-tooltip").remove();
                // Only apply legend filters if there are more than 1 active legend items
                var activeLegendItems = self.getActiveLegendItems();
                var legendButton = select(this);
                var enabling = !legendButton.classed("active");
                // If there are more than 1 active legend items & one is getting toggled on
                if (activeLegendItems.length > 1 || enabling) {
                    self.updateLegend(this);
                    self.applyLegendFilter(legendButton.select("text").text());
                }
                // If there are 2 active legend items & one is getting toggled off
                if (activeLegendItems.length === 2 && !enabling) {
                    c.selectAll(".legend-btn.active").classed("not-allowed", true);
                }
                if (activeLegendItems.length === 1 && enabling) {
                    c.selectAll(".legend-btn.not-allowed").classed("not-allowed", false);
                }
            });
        });
    };
    BaseChart.prototype.setChartIDContainer = function () {
        var parent = select(this.holder);
        var chartId, container;
        if (parent.select(".chart-wrapper").nodes().length > 0) {
            container = parent.select(".chart-wrapper");
            chartId = container.attr("chart-id");
            container.selectAll(".chart-svg").remove();
        }
        else {
            chartId = this.id;
            container = parent.append("div");
            container.attr("chart-id", chartId)
                .classed("chart-wrapper", true)
                .classed("carbon--theme--" + this.options.theme, true);
            if (container.select(".legend-wrapper").nodes().length === 0) {
                var legendWrapper = container.append("div")
                    .attr("class", "legend-wrapper")
                    .attr("role", "region")
                    .attr("aria-label", "Chart " + chartId + " Legend");
                legendWrapper.append("ul")
                    .attr("class", "legend");
            }
        }
        return { chartId: chartId, container: container };
    };
    BaseChart.prototype.resetOpacity = function () {
        var svg = selectAll("svg.chart-svg");
        svg.selectAll("rect")
            .attr("fill-opacity", Configuration.charts.resetOpacity.opacity)
            .attr("stroke-opacity", Configuration.charts.resetOpacity.opacity);
    };
    BaseChart.prototype.reduceOpacity = function (exception) {
        var _this = this;
        var exceptedElement = select(exception);
        var exceptedElementData = exceptedElement.datum();
        select(exception).attr("fill-opacity", false);
        select(exception).attr("stroke-opacity", Configuration.charts.reduceOpacity.opacity);
        select(exception).attr("fill", function (d) { return _this.getFillColor(d.datasetLabel, exceptedElementData.label, exceptedElementData.value); });
    };
    // ================================================================================
    // Legend
    // ================================================================================
    BaseChart.prototype.getLegendItems = function () {
        var legendItems = {};
        if (this.options.keys) {
            legendItems = this.options.keys;
        }
        return legendItems;
    };
    BaseChart.prototype.getLegendItemArray = function () {
        var legendItems = this.getLegendItems();
        var legendItemKeys = Object.keys(legendItems);
        return legendItemKeys.map(function (key) { return ({
            key: key,
            value: legendItems[key]
        }); });
    };
    BaseChart.prototype.getLegendItemKeys = function () {
        return Object.keys(this.getLegendItems());
    };
    BaseChart.prototype.getDisabledLegendItems = function () {
        var legendItems = this.getLegendItems();
        var legendItemKeys = Object.keys(legendItems);
        return legendItemKeys.filter(function (itemKey) { return legendItems[itemKey] === Configuration.legend.items.status.DISABLED; });
    };
    BaseChart.prototype.getActiveLegendItems = function () {
        var legendItems = this.getLegendItems();
        var legendItemKeys = Object.keys(legendItems);
        return legendItemKeys.filter(function (itemKey) { return legendItems[itemKey] === Configuration.legend.items.status.ACTIVE; });
    };
    BaseChart.prototype.updateLegend = function (legend) {
        var thisLegend = select(legend);
        var circle = select(legend).select(".legend-circle");
        thisLegend.classed("active", !thisLegend.classed("active"));
        if (thisLegend.classed("active")) {
            circle.style("background-color", circle.style("border-color"))
                .style("border-color", Configuration.legend.active.borderColor)
                .style("border-style", Configuration.legend.active.borderStyle)
                .style("border-width", Configuration.legend.active.borderWidth);
        }
        else {
            circle.style("border-color", circle.style("background-color"))
                .style("background-color", Configuration.legend.inactive.backgroundColor)
                .style("border-style", Configuration.legend.inactive.borderStyle)
                .style("border-width", Configuration.legend.inactive.borderWidth);
        }
    };
    BaseChart.prototype.addLegend = function () {
        var _this = this;
        if (this.container.select(".legend-tooltip").nodes().length > 0) {
            return;
        }
        var legendItemsArray = this.getLegendItemArray();
        var legendItems = this.container.select(".legend")
            .attr("font-size", Configuration.legend.fontSize)
            .selectAll("li.legend-btn")
            .data(legendItemsArray, function (d) { return d.key; });
        legendItems.exit()
            .remove();
        var legendEnter = legendItems.enter()
            .append("li")
            .attr("class", "legend-btn active");
        legendEnter.append("div")
            .attr("class", "legend-circle");
        legendEnter.append("text");
        legendEnter.selectAll("text")
            .merge(legendItems.selectAll("text"))
            .text(function (d) { return d.key; });
        legendEnter.select("div")
            .merge(legendItems.selectAll("div"))
            .style("background-color", function (d, i) {
            if (_this.getLegendType() === Configuration.legend.basedOn.LABELS && d.value === Configuration.legend.items.status.ACTIVE) {
                return _this.getStrokeColor(_this.displayData.datasets[0].label, d.key, d.value);
            }
            else if (d.value === Configuration.legend.items.status.ACTIVE) {
                return _this.getStrokeColor(d.key);
            }
            return "white";
        });
    };
    BaseChart.prototype.positionLegend = function () {
        if (this.container.select(".legend-tooltip").nodes().length > 0
            && this.container.select(".legend-tooltip").node().style.display === "block") {
            return;
        }
        var svgWidth = this.container.select("g.inner-wrap").node().getBBox().width;
        if (this.isLegendOnRight()) {
            this.container.selectAll(".expand-btn").remove();
            this.container.select(".legend-wrapper").style("height", 0);
            this.container.select(".legend").classed("right-legend", true);
        }
        else {
            this.container.select(".legend-wrapper").style("height", Configuration.legend.wrapperHeight);
        }
        if (this.hasLegendExpandBtn()) {
            this.container.select(".legend").classed("right-legend", false)
                .style("width", null);
            var btns = this.container.selectAll(".legend-btn").nodes();
            var btnsWidth_1 = 0;
            btns.forEach(function (btn) {
                if ((btnsWidth_1 + btn.clientWidth + Configuration.legend.widthTolerance) > svgWidth) {
                    select(btn).style("display", "none");
                }
                else {
                    btnsWidth_1 += btn.clientWidth;
                }
            });
            if (this.container.select(".expand-btn").nodes().length === 0) {
                this.addTooltipOpenButtonToLegend();
            }
        }
        else {
            this.container.selectAll(".legend-btn").style("display", null);
        }
    };
    BaseChart.prototype.addOrUpdateLegend = function () {
        this.addLegend();
        if (this.options.legendClickable) {
            this.setClickableLegend();
        }
        this.positionLegend();
    };
    BaseChart.prototype.addLegendCircleHoverEffect = function () {
        this.container.selectAll("li.legend-btn")
            .on("mouseover", function () {
            var circleRef = select(this).select("div.legend-circle");
            var color = circleRef.node().style.backgroundColor.substring(4, circleRef.node().style.backgroundColor.length - 1);
            circleRef.style("box-shadow", "0 0 0 " + Configuration.legend.hoverShadowSize + " rgba(" + color + ", " + Configuration.legend.hoverShadowTransparency + ")");
        })
            .on("mouseout", function () {
            select(this).select("div.legend-circle").style("box-shadow", "none");
        });
    };
    BaseChart.prototype.hasLegendExpandBtn = function () {
        return this.container.node().clientWidth < Configuration.charts.widthBreak ||
            this.container.node().clientHeight < this.container.select("ul.legend").node().clientHeight;
    };
    BaseChart.prototype.isLegendOnRight = function () {
        return this.container.node().clientWidth >= Configuration.charts.widthBreak &&
            this.container.node().clientHeight >= this.container.select("ul.legend").node().clientHeight;
    };
    /**
     *
     * When a legend item is clicked, apply/remove the appropriate filter
     * @param {string} changedLabel The label of the legend element the user clicked on
     * @memberof PieChart
     */
    BaseChart.prototype.applyLegendFilter = function (changedLabel) {
        var _a = Configuration.legend.items.status, ACTIVE = _a.ACTIVE, DISABLED = _a.DISABLED;
        var oldStatus = this.options.keys[changedLabel];
        this.options.keys[changedLabel] = (oldStatus === ACTIVE ? DISABLED : ACTIVE);
        this.update();
    };
    BaseChart.prototype.setClickableLegendInTooltip = function () {
        var self = this;
        var c = select(this.container);
        var tooltip = c.select(".legend-tooltip-content");
        tooltip.selectAll(".legend-btn").each(function () {
            select(this).on("click", function () {
                self.updateLegend(this);
                // TODO - setClickableLegendInTooltip()
            });
        });
    };
    // ================================================================================
    // Tooltips
    // ================================================================================
    BaseChart.prototype.addTooltipOpenButtonToLegend = function () {
        var self = this;
        var thisLegend = this.container.select(".legend");
        thisLegend.append("div")
            .attr("class", "expand-btn")
            .style("cursor", "pointer")
            .on("click", function () {
            self.openLegendTooltip(this);
        });
    };
    // TODO - Refactor
    BaseChart.prototype.openLegendTooltip = function (target) {
        var _this = this;
        selectAll(".legend-tooltip").remove();
        var mouseXPoint = mouse(this.container.node())[0];
        var windowXPoint = event.x;
        var tooltip;
        if (this.container.select(".legend-tooltip").nodes().length > 0) {
            tooltip = selectAll(".legend-tooltip").style("display", "block");
            tooltip.select("arrow").remove();
        }
        else {
            tooltip = this.container.append("div")
                .attr("class", "tooltip chart-tooltip legend-tooltip")
                .style("display", "block")
                .style("top", (mouse(this.container.node())[1] - Configuration.legend.margin.top) + "px");
            tooltip.append("p").text("Legend")
                .attr("class", "legend-tooltip-header");
            tooltip.append("ul")
                .attr("class", "legend-tooltip-content")
                .attr("font-size", Configuration.legend.fontSize);
            Tools.addCloseBtn(tooltip, "md", "white")
                .on("click", function () {
                selectAll(".legend-tooltip").style("display", "none");
            });
            var activeLegendItems_1 = this.getActiveLegendItems();
            var legendContent = select(".legend-tooltip-content")
                .attr("font-size", Configuration.legend.fontSize)
                .selectAll("div")
                .data(this.getLegendItemArray(), function (d) { return d.key; })
                .enter()
                .append("li")
                .classed("legend-btn", true)
                .classed("clickable", this.options.legendClickable)
                .classed("active", function (d) { return d.value === Configuration.legend.items.status.ACTIVE; })
                .classed("not-allowed", function (d) { return activeLegendItems_1.length === 1 && d.value === Configuration.legend.items.status.ACTIVE; })
                .on("click", function (clickedItem, e) {
                if (!_this.options.legendClickable) {
                    return;
                }
                var legendButton = select(event.currentTarget);
                var enabling = !legendButton.classed("active");
                if (activeLegendItems_1.length > 1 || enabling) {
                    _this.updateLegend(event.currentTarget);
                    _this.applyLegendFilter(clickedItem.key);
                    _this.container.selectAll("ul.legend li.legend-btn")
                        .data(_this.getLegendItemArray(), function (d) { return d.key; })
                        .classed("active", function (d) { return d.value === Configuration.legend.items.status.ACTIVE; })
                        .select("div.legend-circle")
                        .style("background-color", function (d, i) {
                        if (_this.getLegendType() === Configuration.legend.basedOn.LABELS && d.value === Configuration.legend.items.status.ACTIVE) {
                            return _this.getStrokeColor(_this.displayData.datasets[0].label, d.key, d.value);
                        }
                        else if (d.value === Configuration.legend.items.status.ACTIVE) {
                            return _this.getStrokeColor(d.key);
                        }
                        return "white";
                    })
                        .style("border-color", function (d) {
                        if (_this.getLegendType() === Configuration.legend.basedOn.LABELS) {
                            return _this.getStrokeColor(_this.displayData.datasets[0].label, d.key, d.value);
                        }
                        else {
                            return _this.getStrokeColor(d.key);
                        }
                    })
                        .style("border-style", Configuration.legend.inactive.borderStyle)
                        .style("border-width", Configuration.legend.inactive.borderWidth);
                }
                // If there are 2 active legend items & one is getting toggled off
                if (activeLegendItems_1.length === 2 && !enabling) {
                    _this.container.selectAll(".legend-btn.active").classed("not-allowed", true);
                }
                if (activeLegendItems_1.length === 1 && enabling) {
                    _this.container.selectAll(".legend-btn.not-allowed").classed("not-allowed", false);
                }
            });
            legendContent.append("div")
                .attr("class", "legend-circle")
                .style("background-color", function (d, i) {
                if (_this.getLegendType() === Configuration.legend.basedOn.LABELS && d.value === Configuration.legend.items.status.ACTIVE) {
                    return _this.getStrokeColor(_this.displayData.datasets[0].label, d.key, d.value);
                }
                else if (d.value === Configuration.legend.items.status.ACTIVE) {
                    return _this.getStrokeColor(d.key);
                }
                return "white";
            })
                .style("border-color", function (d) {
                if (_this.getLegendType() === Configuration.legend.basedOn.LABELS) {
                    return _this.getStrokeColor(_this.displayData.datasets[0].label, d.key, d.value);
                }
                else {
                    return _this.getStrokeColor(d.key);
                }
            })
                .style("border-style", Configuration.legend.inactive.borderStyle)
                .style("border-width", Configuration.legend.inactive.borderWidth);
            legendContent.append("text")
                .text(function (d) { return d.key; });
        }
        // Position the tooltip
        tooltip.classed("arrow-right", true);
        tooltip.append("div").attr("class", "arrow");
        tooltip.style("left", mouseXPoint - Configuration.tooltip.width - Configuration.tooltip.arrowWidth + "px");
        if (this.options.legendClickable) {
            this.addLegendCircleHoverEffect();
        }
    };
    BaseChart.prototype.showLabelTooltip = function (d, leftSide) {
        var _this = this;
        selectAll(".label-tooltip").remove();
        var mouseXPoint = mouse(this.holder)[0] + Configuration.tooltip.arrowWidth;
        var tooltip = this.container.append("div")
            .attr("class", "tooltip label-tooltip")
            .style("top", mouse(this.holder)[1] - Configuration.tooltip.magicTop1 + "px");
        Tools.addCloseBtn(tooltip, "xs")
            .on("click", function () {
            _this.resetOpacity();
            selectAll(".tooltip").remove();
        });
        tooltip.append("p").text(d);
        if (leftSide) {
            tooltip.classed("arrow-left", true)
                .style("left", mouseXPoint + "px")
                .append("div").attr("class", "arrow");
        }
        else {
            tooltip.classed("arrow-right", true);
            var xPoint = mouseXPoint - tooltip.node().clientWidth - Configuration.tooltip.magicXPoint2;
            tooltip.style("left", xPoint + "px")
                .append("div").attr("class", "arrow");
        }
    };
    BaseChart.prototype.hideTooltip = function () {
        this.resetOpacity();
        this.tooltip.hide();
    };
    BaseChart.prototype.generateTooltipHTML = function (label, value) {
        if (this.options.tooltip.size === Configuration.tooltip.size.COMPACT) {
            return "<b>" + label + ":</b> " + value + "<br/>";
        }
        else {
            return "\n\t\t\t\t<p class='bignum'>" + label + "</p>\n\t\t\t\t<p>" + value + "</p>\n\t\t\t";
        }
    };
    BaseChart.prototype.showTooltip = function (d, clickedElement) {
        // Reset opacity of all elements in the chart
        this.resetOpacity();
        var customHTML = this.options.tooltip.customHTML;
        var contentHTML;
        if (customHTML) {
            contentHTML = customHTML;
        }
        else {
            contentHTML = this.getTooltipHTML(d);
        }
        this.tooltip.show(contentHTML);
    };
    BaseChart.prototype.getFillScale = function () {
        return this.options.accessibility ? this.patternScale : this.colorScale;
    };
    BaseChart.prototype.getDefaultTransition = function (type) {
        if (this.options.animations === false) {
            return this.getInstantTransition();
        }
        else if (Configuration.transitions[type]) {
            return transition().duration(Configuration.transitions[type].duration);
        }
        return transition().duration(Configuration.transitions.default.duration);
    };
    BaseChart.prototype.getInstantTransition = function () {
        return transition().duration(0);
    };
    // Used to determine whether to use a transition for updating fill attributes in charting elements
    // Will disable the transition if in accessibility mode
    BaseChart.prototype.getFillTransition = function (animate) {
        if (this.options.animations === false) {
            return this.getInstantTransition();
        }
        return transition().duration(animate === false ? 0 : Configuration.transitions.default.duration);
    };
    BaseChart.prototype.getBBox = function (selector) {
        return this.innerWrap.select(selector).node().getBBox();
    };
    BaseChart.chartCount = 1;
    return BaseChart;
}());
export { BaseChart };
//# sourceMappingURL=/home/travis/build/carbon-design-system/carbon-charts/packages/core/base-chart.js.map