var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// D3 Imports
import { select } from "d3-selection";
import { line } from "d3-shape";
import { ScatterChart } from "./scatter-chart";
import * as Configuration from "./configuration";
import { ChartType } from "./configuration";
import { getD3Curve } from "./services/curves";
import { Tools } from "./tools";
var LineChart = /** @class */ (function (_super) {
    __extends(LineChart, _super);
    function LineChart(holder, configs) {
        var _this = _super.call(this, holder, configs) || this;
        // initialize options
        if (configs.options) {
            _this.options = Tools.merge({}, Configuration.options.LINE, configs.options);
        }
        else {
            _this.options = Tools.merge({}, Configuration.options.LINE);
        }
        _this.options.type = ChartType.LINE;
        return _this;
    }
    LineChart.prototype.draw = function () {
        var _this = this;
        this.innerWrap.style("width", "100%")
            .style("height", "100%");
        var margins = Configuration.charts.margin.line;
        this.innerWrap.style("width", "100%").style("height", "100%");
        this.innerWrap.attr("transform", "translate(" + margins.left + ", " + margins.top + ")");
        var curveName;
        var curveOptions;
        this.options.curve = this.options.curve || "curveLinear";
        if (typeof this.options.curve === "string") {
            curveName = this.options.curve;
            curveOptions = {};
        }
        else {
            curveName = this.options.curve.name || "curveLinear";
            curveOptions = this.options.curve;
            delete curveOptions["name"];
        }
        // D3 line generator function
        this.lineGenerator = line()
            .x(function (d, i) { return _this.x(_this.displayData.labels[i]) + _this.x.step() / 2; })
            .y(function (d) { return _this.y(d); })
            .curve(getD3Curve(curveName, curveOptions));
        var gLines = this.innerWrap.selectAll("g.lines")
            .data(this.displayData.datasets)
            .enter()
            .append("g")
            .classed("lines", true);
        gLines.append("path")
            .attr("stroke", function (d) { return _this.getStrokeColor(d.label); })
            .datum(function (d) { return d.data; })
            .attr("class", "line")
            .attr("d", this.lineGenerator);
        _super.prototype.draw.call(this);
    };
    LineChart.prototype.interpolateValues = function (newData) {
        var _this = this;
        var margins = Configuration.charts.margin.line;
        var chartSize = this.getChartSize();
        var width = chartSize.width - margins.left - margins.right;
        var height = chartSize.height - this.getBBox(".x.axis").height;
        this.innerWrap.selectAll(".removed")
            .remove();
        // Apply new data to the lines
        var gLines = this.innerWrap.selectAll("g.lines")
            .data(newData.datasets);
        this.updateElements(true, gLines);
        // Add lines that need to be added now
        var addedLineGroups = gLines.enter()
            .append("g")
            .classed("lines", true);
        addedLineGroups.append("path")
            .attr("stroke", function (d) { return _this.getStrokeColor(d.label); })
            .datum(function (d) { return d.data; })
            .style("opacity", 0)
            .transition(this.getDefaultTransition())
            .style("opacity", 1)
            .attr("class", "line")
            .attr("d", this.lineGenerator);
        // Remove lines that are no longer needed
        gLines.exit()
            .classed("removed", true) // mark this element with "removed" class so it isn't reused
            .transition(this.getDefaultTransition())
            .style("opacity", 0)
            .remove();
        _super.prototype.interpolateValues.call(this, newData);
    };
    LineChart.prototype.updateElements = function (animate, gLines) {
        if (!gLines) {
            gLines = this.innerWrap.selectAll("g.lines");
        }
        var transitionToUse = animate ? this.getFillTransition() : this.getInstantTransition();
        var self = this;
        gLines.selectAll("path.line")
            .datum(function (d) {
            var parentDatum = select(this.parentNode).datum();
            return parentDatum.data;
        })
            .transition(transitionToUse)
            .style("opacity", 1)
            .attr("stroke", function (d) {
            var parentDatum = select(this.parentNode).datum();
            return self.getStrokeColor(parentDatum.label);
        })
            .attr("class", "line")
            .attr("d", this.lineGenerator);
        _super.prototype.updateElements.call(this, animate);
    };
    return LineChart;
}(ScatterChart));
export { LineChart };
//# sourceMappingURL=/home/travis/build/carbon-design-system/carbon-charts/packages/core/line-chart.js.map