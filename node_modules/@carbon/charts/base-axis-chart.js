var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
// D3 Imports
import { select } from "d3-selection";
import { scaleBand, scaleLinear } from "d3-scale";
import { axisBottom, axisLeft, axisRight } from "d3-axis";
import { min, max } from "d3-array";
import { BaseChart } from "./base-chart";
import * as Configuration from "./configuration";
import { Tools } from "./tools";
var BaseAxisChart = /** @class */ (function (_super) {
    __extends(BaseAxisChart, _super);
    function BaseAxisChart(holder, configs) {
        var _this = _super.call(this, holder, configs) || this;
        _this.options = Tools.merge({}, Configuration.options.AXIS);
        if (configs.options) {
            _this.options = Tools.merge({}, _this.options, configs.options);
            var axis = configs.options.axis;
            if (axis) {
                _this.x = axis.x;
                _this.y = axis.y;
                _this.y2 = axis.y2;
            }
        }
        return _this;
    }
    BaseAxisChart.prototype.setSVG = function () {
        _super.prototype.setSVG.call(this);
        this.container.classed("chart-axis", true);
        this.innerWrap.append("g")
            .attr("class", "x grid");
        this.innerWrap.append("g")
            .attr("class", "y grid");
        return this.svg;
    };
    BaseAxisChart.prototype.initialDraw = function (data) {
        if (data) {
            this.displayData = data;
        }
        // If an axis exists
        var xAxisRef = select(this.holder).select(".axis.x");
        if (!xAxisRef.node()) {
            this.setSVG();
            // Scale out the domains
            // Set the x & y axis as well as their labels
            this.setXScale();
            this.setXAxis();
            this.setYScale();
            this.setYAxis();
            // Draws the grid
            this.drawGrid();
            this.addOrUpdateLegend();
        }
        else {
            var holderRef = select(this.holder);
            this.innerWrap = holderRef.select("g.inner-wrap");
            this.svg = holderRef.select("svg.chart-svg");
        }
        this.draw();
        this.addDataPointEventListener();
    };
    BaseAxisChart.prototype.update = function () {
        this.displayData = this.updateDisplayData();
        this.updateXandYGrid();
        this.setXScale();
        this.setXAxis();
        this.setYScale();
        this.setYAxis();
        this.drawBackdrop();
        this.interpolateValues(this.displayData);
    };
    BaseAxisChart.prototype.updateDisplayData = function () {
        var oldData = Tools.clone(this.data);
        var activeLegendItems = this.getActiveLegendItems();
        // Get new data by filtering the data based off of the legend
        var newDisplayData = Object.assign({}, oldData);
        if (this.getLegendType() === Configuration.legend.basedOn.SERIES) {
            newDisplayData.datasets = oldData.datasets.filter(function (dataset) {
                // If this datapoint is active on the legend
                var activeSeriesItemIndex = activeLegendItems.indexOf(dataset.label);
                return activeSeriesItemIndex !== -1;
            });
        }
        else {
            var dataIndeciesToRemove_1 = [];
            newDisplayData.labels = oldData.labels.filter(function (label, index) {
                // If this datapoint is active on the legend
                var activeSeriesItemIndex = activeLegendItems.indexOf(label);
                if (activeSeriesItemIndex === -1) {
                    dataIndeciesToRemove_1.push(index);
                }
                return activeSeriesItemIndex !== -1;
            });
            if (dataIndeciesToRemove_1.length > 0) {
                newDisplayData.datasets = oldData.datasets.map(function (dataset) {
                    dataset.data = dataset.data.filter(function (dataPoint, i) {
                        return dataIndeciesToRemove_1.indexOf(i) === -1;
                    });
                    return dataset;
                });
            }
        }
        return newDisplayData;
    };
    BaseAxisChart.prototype.addLabelsToDataPoints = function (d, index) {
        var datasets = this.displayData.datasets;
        return datasets.map(function (dataset) { return ({
            label: d,
            datasetLabel: dataset.label,
            value: dataset.data[index]
        }); });
    };
    BaseAxisChart.prototype.draw = function () {
        console.warn("You should implement your own `draw()` function.");
    };
    BaseAxisChart.prototype.interpolateValues = function (newData) {
        console.warn("You should implement your own `interpolateValues()` function.");
    };
    /**************************************
     *  Computations/Calculations         *
     *************************************/
    // TODO - Refactor
    BaseAxisChart.prototype.getChartSize = function (container) {
        if (container === void 0) { container = this.container; }
        var ratio, marginForLegendTop, marginForChartTitle;
        if (container.node().clientWidth > Configuration.charts.widthBreak) {
            ratio = Configuration.charts.magicRatio;
            marginForLegendTop = 0;
        }
        else {
            marginForLegendTop = Configuration.charts.marginForLegendTop;
            ratio = 1;
        }
        // Store computed actual size, to be considered for change if chart does not support axis
        var marginsToExclude = Configuration.charts.margin.left + Configuration.charts.margin.right;
        marginForChartTitle = this.options.title ? Configuration.charts.title.marginBottom : 0;
        var computedChartSize = {
            height: container.node().clientHeight - marginForLegendTop - marginForChartTitle,
            width: (container.node().clientWidth - marginsToExclude) * ratio
        };
        return {
            height: Math.max(computedChartSize.height, Configuration.charts.axisCharts.minHeight),
            width: Math.max(computedChartSize.width, Configuration.charts.axisCharts.minWidth)
        };
    };
    BaseAxisChart.prototype.resizeChart = function () {
        // Reposition the legend
        this.positionLegend();
        if (this.innerWrap.select(".axis-label.x").nodes().length > 0 || this.options.scales.x.title) {
            this.repositionXAxisTitle();
        }
        if (this.innerWrap.select(".axis-label.y").nodes().length > 0 || this.options.scales.y.title) {
            this.repositionYAxisTitle();
        }
        this.dispatchEvent("resize");
        this.drawBackdrop();
    };
    /**************************************
     *  Axis & Grids                      *
     *************************************/
    BaseAxisChart.prototype.setXScale = function (xScale) {
        if (xScale) {
            this.x = xScale;
        }
        else {
            var margins = Configuration.charts.margin.bar;
            var scales = this.options.scales;
            var chartSize = this.getChartSize();
            var width = chartSize.width - margins.left - margins.right;
            this.x = scaleBand().rangeRound([0, width]).padding(Configuration.scales.x.padding);
            this.x.domain(this.displayData.labels);
        }
    };
    BaseAxisChart.prototype.setXAxis = function (noAnimation) {
        var _this = this;
        var margins = Configuration.charts.margin.bar;
        var chartSize = this.getChartSize();
        var height = chartSize.height - margins.top - margins.bottom;
        var t = noAnimation ? this.getInstantTransition() : this.getDefaultTransition();
        var xAxis = axisBottom(this.x)
            .tickSize(0)
            .tickSizeOuter(0);
        var xAxisRef = this.svg.select("g.x.axis");
        // If the <g class="x axis"> exists in the chart SVG, just update it
        if (xAxisRef.nodes().length > 0) {
            xAxisRef = this.svg.select("g.x.axis")
                .transition(t)
                .attr("transform", "translate(0, " + height + ")")
                .call(xAxis);
        }
        else {
            xAxisRef = this.innerWrap.append("g")
                .attr("class", "x axis");
            xAxisRef.call(xAxis);
        }
        // Update the position of the pieces of text inside x-axis
        xAxisRef.selectAll("g.tick text")
            .attr("y", Configuration.scales.magicY1)
            .attr("x", Configuration.scales.magicX1)
            .attr("dy", ".35em")
            .attr("transform", "rotate(" + Configuration.scales.xAxisAngle + ")")
            .style("text-anchor", "end")
            .call(function (text) { return _this.wrapTick(text); });
        // get the tickHeight after the ticks have been wrapped
        var tickHeight = this.getLargestTickHeight(xAxisRef.selectAll(".tick")) + Configuration.scales.tick.heightAddition;
        // Add x-axis title
        if (this.innerWrap.select(".axis-label.x").nodes().length === 0 && this.options.scales.x.title) {
            xAxisRef.append("text")
                .attr("class", "x axis-label")
                .attr("text-anchor", "middle")
                .attr("transform", "translate(" + xAxisRef.node().getBBox().width / 2 + ", " + tickHeight + ")")
                .text(this.options.scales.x.title);
        }
        // get the yHeight after the height of the axis has settled
        var yHeight = this.getChartSize().height - this.svg.select(".x.axis").node().getBBox().height;
        xAxisRef.attr("transform", "translate(0, " + yHeight + ")");
    };
    BaseAxisChart.prototype.repositionXAxisTitle = function () {
        var xAxisRef = this.svg.select("g.x.axis");
        var tickHeight = this.getLargestTickHeight(xAxisRef.selectAll(".tick")) + Configuration.scales.tick.heightAddition;
        var xAxisTitleRef = this.svg.select("g.x.axis text.x.axis-label");
        xAxisTitleRef.attr("class", "x axis-label")
            .attr("text-anchor", "middle")
            .attr("transform", "translate(" + xAxisRef.node().getBBox().width / 2 + ", " + tickHeight + ")")
            .text(this.options.scales.x.title);
    };
    BaseAxisChart.prototype.repositionYAxisTitle = function () {
        var yAxisRef = this.svg.select("g.y.axis");
        var tickHeight = this.getLargestTickHeight(yAxisRef.selectAll(".tick"));
        var yAxisTitleRef = this.svg.select("g.y.axis text.y.axis-label");
        var yAxisCenter = yAxisRef.node().getBBox().height / 2;
        var yAxisLabelWidth = this.innerWrap.select(".axis-label.y").node().getBBox().width;
        var yAxisTitleTranslate = {
            x: -yAxisCenter + yAxisLabelWidth / 2,
            y: -(tickHeight + Configuration.scales.tick.heightAddition)
        };
        // Align y axis title with y axis
        yAxisTitleRef.attr("class", "y axis-label")
            .attr("text-align", "center")
            .attr("transform", "rotate(-90) translate(" + yAxisTitleTranslate.x + ", " + yAxisTitleTranslate.y + ")")
            .text(this.options.scales.y.title);
    };
    BaseAxisChart.prototype.getYMax = function () {
        var datasets = this.displayData.datasets;
        var scales = this.options.scales;
        var yMax;
        if (datasets.length === 1) {
            yMax = max(datasets[0].data);
        }
        else {
            yMax = max(datasets, function (d) { return (max(d.data)); });
        }
        if (scales.y.yMaxAdjuster) {
            yMax = scales.y.yMaxAdjuster(yMax);
        }
        return yMax;
    };
    BaseAxisChart.prototype.getYMin = function () {
        var datasets = this.displayData.datasets;
        var scales = this.options.scales;
        var yMin;
        if (datasets.length === 1) {
            yMin = min(datasets[0].data);
        }
        else {
            yMin = min(datasets, function (d) { return (min(d.data)); });
        }
        if (scales.y.yMinAdjuster) {
            yMin = scales.y.yMinAdjuster(yMin);
        }
        return yMin;
    };
    BaseAxisChart.prototype.setYScale = function (yScale) {
        var chartSize = this.getChartSize();
        var height = chartSize.height - this.innerWrap.select(".x.axis").node().getBBox().height;
        var scales = this.options.scales;
        var yMin = this.getYMin();
        var yMax = this.getYMax();
        if (yScale) {
            this.y = yScale;
        }
        else {
            this.y = scaleLinear().range([height, 0]);
            this.y.domain([Math.min(yMin, 0), yMax]);
        }
        if (scales.y2 && scales.y2.ticks.max) {
            this.y2 = scaleLinear().rangeRound([height, 0]);
            this.y2.domain([scales.y2.ticks.min, scales.y2.ticks.max]);
        }
    };
    BaseAxisChart.prototype.setYAxis = function (noAnimation) {
        var chartSize = this.getChartSize();
        var scales = this.options.scales;
        var t = noAnimation ? this.getInstantTransition() : this.getDefaultTransition();
        var yAxis = axisLeft(this.y)
            .ticks(scales.y.numberOfTicks || Configuration.scales.y.numberOfTicks)
            .tickSize(0)
            .tickFormat(scales.y.formatter);
        var yAxisRef = this.svg.select("g.y.axis");
        var horizontalLine = this.svg.select("line.domain");
        this.svg.select("g.x.axis path.domain")
            .remove();
        // If the <g class="y axis"> exists in the chart SVG, just update it
        if (yAxisRef.nodes().length > 0) {
            yAxisRef.transition(t)
                .call(yAxis);
            horizontalLine.transition(t)
                .attr("y1", this.y(0))
                .attr("y2", this.y(0))
                .attr("x1", 0)
                .attr("x2", chartSize.width);
        }
        else {
            yAxisRef = this.innerWrap.append("g")
                .attr("class", "y axis yAxes");
            yAxisRef.call(yAxis);
            yAxisRef.append("line")
                .classed("domain", true)
                .attr("y1", this.y(0))
                .attr("y2", this.y(0))
                .attr("x1", 0)
                .attr("x2", chartSize.width);
        }
        var tickHeight = this.getLargestTickHeight(yAxisRef.selectAll(".tick"));
        // Add y-axis title
        if (this.innerWrap.select(".axis-label.y").nodes().length === 0 && this.options.scales.y.title) {
            yAxisRef.append("text")
                .attr("class", "y axis-label")
                .text(this.options.scales.y.title);
            var yAxisCenter = yAxisRef.node().getBBox().height / 2;
            var yAxisLabelWidth = this.innerWrap.select(".axis-label.y").node().getBBox().width;
            var yAxisTitleTranslate = {
                x: -yAxisCenter + yAxisLabelWidth / 2,
                y: -(tickHeight + Configuration.scales.tick.heightAddition)
            };
            // Align y axis title on the y axis
            this.innerWrap.select(".axis-label.y")
                .attr("transform", "rotate(-90) translate(" + yAxisTitleTranslate.x + ", " + yAxisTitleTranslate.y + ")");
        }
        Tools.moveToFront(horizontalLine);
        if (scales.y2 && scales.y2.ticks.max) {
            var secondaryYAxis = axisRight(this.y2)
                .ticks(scales.y2.numberOfTicks || Configuration.scales.y2.numberOfTicks)
                .tickSize(0)
                .tickFormat(scales.y2.formatter);
            var secondaryYAxisRef = this.svg.select("g.y2.axis");
            // If the <g class="y axis"> exists in the chart SVG, just update it
            if (secondaryYAxisRef.nodes().length > 0) {
                secondaryYAxisRef.transition(t)
                    .attr("transform", "translate(" + this.getChartSize().width + ", 0)")
                    .call(secondaryYAxis);
            }
            else {
                this.innerWrap.append("g")
                    .attr("class", "y2 axis yAxes")
                    .attr("transform", "translate(" + this.getChartSize().width + ", 0)")
                    .call(secondaryYAxis);
            }
        }
    };
    BaseAxisChart.prototype.drawGrid = function () {
        // Draw the x & y grid
        this.drawXGrid();
        this.drawYGrid();
        // Draw the backdrop
        this.drawBackdrop();
    };
    BaseAxisChart.prototype.drawXGrid = function () {
        var yHeight = this.getChartSize().height - this.getBBox(".x.axis").height;
        var xGrid = axisBottom(this.x)
            .tickSizeInner(-yHeight)
            .tickSizeOuter(0);
        var g = this.innerWrap.select(".x.grid")
            .attr("transform", "translate(0, " + yHeight + ")")
            .call(xGrid);
        this.cleanGrid(g);
    };
    BaseAxisChart.prototype.drawYGrid = function () {
        var scales = this.options.scales;
        var thresholds = this.options.scales.y.thresholds;
        var yHeight = this.getChartSize().height - this.getBBox(".x.axis").height;
        var yGrid = axisLeft(this.y)
            .tickSizeInner(-this.getChartSize().width)
            .tickSizeOuter(0);
        yGrid.ticks(scales.y.numberOfTicks || Configuration.scales.y.numberOfTicks);
        var g = this.innerWrap.select(".y.grid")
            .attr("transform", "translate(0, 0)")
            .call(yGrid);
        this.cleanGrid(g);
        if (thresholds && thresholds.length > 0) {
            this.addOrUpdateThresholds(g, false);
        }
    };
    /**
     * Draws the background for the chart grid. Uses the axis to get the bounds and position of the backdrop.
     */
    BaseAxisChart.prototype.drawBackdrop = function () {
        var backdrop = Tools.appendOrSelect(this.innerWrap, "rect.chart-grid-backdrop");
        var _a = this.x.range(), xScaleStart = _a[0], xScaleEnd = _a[1];
        var _b = this.y.range(), yScaleEnd = _b[0], yScaleStart = _b[1];
        backdrop
            .attr("x", xScaleStart)
            .attr("y", yScaleStart)
            .attr("width", xScaleEnd)
            .attr("height", yScaleEnd)
            .lower();
    };
    BaseAxisChart.prototype.addOrUpdateThresholds = function (yGrid, animate) {
        var _this = this;
        var t = animate === false ? this.getInstantTransition() : this.getDefaultTransition();
        var width = this.getChartSize().width;
        var thresholds = this.options.scales.y.thresholds;
        // Check if the thresholds container <g> exists
        var thresholdContainerExists = this.innerWrap.select("g.thresholds").nodes().length > 0;
        var thresholdRects = thresholdContainerExists
            ? this.innerWrap.selectAll("g.thresholds rect")
            : this.innerWrap.append("g").classed("thresholds", true).selectAll("rect").data(thresholds);
        var calculateYPosition = function (d) {
            return Math.max(0, _this.y(d.range[1]));
        };
        var calculateHeight = function (d) {
            var height = Math.abs(_this.y(d.range[1]) - _this.y(d.range[0]));
            var yMax = _this.y(_this.y.domain()[0]);
            // If the threshold is getting cropped because it is extending beyond
            // the top of the chart, update its height to reflect the crop
            if (_this.y(d.range[1]) < 0) {
                return Math.max(0, height + _this.y(d.range[1]));
            }
            else if (_this.y(d.range[1]) + height > yMax) {
                // If the threshold is getting cropped because it is extending beyond
                // the bottom of the chart, update its height to reflect the crop
                return Math.max(0, yMax - calculateYPosition(d));
            }
            return Math.max(0, height);
        };
        var calculateOpacity = function (d) {
            var height = Math.abs(_this.y(d.range[1]) - _this.y(d.range[0]));
            // If the threshold is to be shown anywhere
            // outside of the top edge of the chart, hide it
            if (_this.y(d.range[1]) + height <= 0) {
                return 0;
            }
            return 1;
        };
        // Applies to thresholds being added
        thresholdRects.enter()
            .append("rect")
            .classed("threshold-bar", true)
            .attr("x", 0)
            .attr("y", function (d) { return calculateYPosition(d); })
            .attr("width", width)
            .attr("height", function (d) { return calculateHeight(d); })
            .attr("fill", function (d) { return Configuration.scales.y.thresholds.colors[d.theme]; })
            .style("opacity", 0)
            .transition(t)
            .style("opacity", function (d) { return calculateOpacity(d); });
        // Update thresholds
        thresholdRects
            .transition(t)
            .attr("x", 0)
            .attr("y", function (d) { return calculateYPosition(d); })
            .attr("width", width)
            .attr("height", function (d) { return calculateHeight(d); })
            .style("opacity", function (d) { return calculateOpacity(d); })
            .attr("fill", function (d) { return Configuration.scales.y.thresholds.colors[d.theme]; });
        // Applies to thresholds getting removed
        thresholdRects.exit()
            .transition(t)
            .style("opacity", 0)
            .remove();
    };
    BaseAxisChart.prototype.updateXandYGrid = function (noAnimation) {
        var _this = this;
        var thresholds = this.options.scales.y.thresholds;
        // setTimeout is needed here, to take into account the new position of bars
        // Right after transitions are initiated for the
        setTimeout(function () {
            var t = noAnimation ? _this.getInstantTransition() : _this.getDefaultTransition();
            // Update X Grid
            var chartSize = _this.getChartSize();
            var yHeight = chartSize.height - _this.getBBox(".x.axis").height;
            var xGrid = axisBottom(_this.x)
                .tickSizeInner(-yHeight)
                .tickSizeOuter(0);
            var g_xGrid = _this.innerWrap.select(".x.grid")
                .transition(t)
                .attr("transform", "translate(0, " + yHeight + ")")
                .call(xGrid);
            _this.cleanGrid(g_xGrid);
            // Update Y Grid
            var yGrid = axisLeft(_this.y)
                .tickSizeInner(-chartSize.width)
                .tickSizeOuter(0)
                .tickFormat("");
            var g_yGrid = _this.innerWrap.select(".y.grid")
                .transition(t)
                .attr("transform", "translate(0, 0)")
                .call(yGrid);
            g_yGrid.transition(t);
            _this.cleanGrid(g_yGrid);
            if (thresholds && thresholds.length > 0) {
                _this.addOrUpdateThresholds(g_yGrid, !noAnimation);
            }
        }, 0);
    };
    BaseAxisChart.prototype.cleanGrid = function (g) {
        g.selectAll("line")
            .attr("stroke", Configuration.grid.strokeColor);
        g.selectAll("text").style("display", "none").remove();
        g.select(".domain").style("stroke", "none");
    };
    // TODO - Refactor
    BaseAxisChart.prototype.wrapTick = function (ticks) {
        var self = this;
        var lineHeight = Configuration.scales.tick.lineHeight;
        ticks.each(function (t) {
            var text = select(this);
            var textContent = text.text();
            // If the text has already been broken down into parts
            if (text.selectAll("tspan").nodes().length > 1) {
                textContent = text.selectAll("tspan")
                    .nodes()
                    .map(function (node) { return select(node).text(); })
                    .join(" ");
            }
            var words = textContent.split(/\s+/).reverse();
            var y = text.attr("y");
            var dy = parseFloat(text.attr("dy"));
            var word;
            var line = [];
            var lineNumber = 0;
            var tspan = text.text(null)
                .append("tspan")
                .attr("x", 0);
            // Set max length allowed to length of datapoints
            // In the x-scale
            var maxTextLengthAllowed = self.x.bandwidth();
            while (word = words.pop()) {
                line.push(word);
                tspan.text(line.join(" "));
                // Get text length and compare to maximum length allowed
                var tspanTextLength = tspan.node().getComputedTextLength();
                if (tspanTextLength > maxTextLengthAllowed) {
                    line.pop();
                    tspan.text(line.join(" "));
                    line = [word];
                    tspan = text.append("tspan")
                        .attr("x", 0)
                        .attr("y", y)
                        .attr("dy", ++lineNumber * lineHeight + dy + "em")
                        .text(word);
                }
            }
        });
    };
    // TODO - Refactor
    BaseAxisChart.prototype.getLargestTickHeight = function (ticks) {
        var largestHeight = 0;
        ticks.each(function () {
            var tickLength = 0;
            try {
                tickLength = this.getBBox().height;
            }
            catch (e) {
                console.log(e);
            }
            if (tickLength > largestHeight) {
                largestHeight = tickLength;
            }
        });
        return largestHeight;
    };
    /**************************************
     *  Events & User interactions        *
     *************************************/
    BaseAxisChart.prototype.addDataPointEventListener = function () {
        console.warn("You should implement your own `addDataPointEventListener()` function.");
    };
    return BaseAxisChart;
}(BaseChart));
export { BaseAxisChart };
//# sourceMappingURL=/home/travis/build/carbon-design-system/carbon-charts/packages/core/base-axis-chart.js.map